{"version":3,"sources":["../source/ucumXmlDocument.js"],"names":["Prefix","require","PrefixTables","Unit","UnitString","UnitTables","jsonfile","fs","xmldoc","essenceFile_","xmlInput_","UcumXmlDocument","data","readFileSync","XmlDocument","holdThis","prototype","Error","exports","self","getInstance","parsePrefixes","childrenNamed","parseBaseUnits","parseUnitStrings","writeJsonFile","writeVersionText","prefixes","plen","length","p","curPfx","attrs","attr","Code","CODE","childNamed","val","pValNode","Math","pow","ptab","isDefined","newPref","add","unitNodes","blen","utab","b","curBUnit","dim","newUnit","addUnit","unitStrings","uStrParser","stopNow","alen","a","haveUnit","curUA","toUpperCase","sym","symVal","replace","trim","symI","toString","compressed","sub","sup","isMetric","isArbitrary","class","valNode","isSpecial","funcNode","name","value","slashPos","indexOf","ar","split","parseFloat","UNIT","substr","exp","parseInt","console","log","PI","retObj","parseString","ret","retString","retMsg","getProperty","newMag","err","message","uList","printUnits","writeFileSync","encoding","mode","flag","licenseText","pfxTabs","pfxArray","allPrefixesByCode","uTabs","uArray","allUnitsByDef","defsHash","dt","Date","valueOf","spaces","rootNode","versionNum","version","revNum","revision","rootString","dateIdx","nextDolIdx","revDate","versionText"],"mappings":"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","file":"ucumXmlDocument.js","sourcesContent":["/**\n * This class handles opening, reading and parsing the XML file of ucum\n * definitions (prefixes, base units, and unit atoms).\n *\n * @author Lee Mericle\n *\n */\nvar Prefix = require(\"./prefix.js\").Prefix;\nvar PrefixTables = require(\"./prefixTables.js\").PrefixTables;\nvar Unit = require(\"./unit.js\").Unit;\nvar UnitString = require(\"./unitString.js\").UnitString;\nvar UnitTables = require('./unitTables.js').UnitTables;\nvar jsonfile = require('jsonfile');\nvar fs = require('fs');\n\nvar xmldoc = require('xmldoc');\nvar fs = require('fs');\n\nvar essenceFile_ = '../data/ucum-essence.xml';\n\n/**\n * The full xml document\n * @type XmlDocument\n */\nvar xmlInput_ = null;\n\nexport class UcumXmlDocument {\n\n\n  /**\n   * Constructor.  This reads the XML document (essenceFile_) into the\n   * xmldoc object, which is an object used by the xmldoc class available\n   * from GitHub - https://github.com/nfarina/xmldoc.  The object provides\n   * methods to read the file and access its contents.\n   *\n   */\n  constructor() {\n    // read the XML file and create an xmlDocument object from it.\n    let data = fs.readFileSync(essenceFile_);\n    xmlInput_ = new xmldoc.XmlDocument(data);\n\n    // Make this a singleton.  See UnitTables constructor for details.\n\n    let holdThis = UcumXmlDocument.prototype;\n    UcumXmlDocument = function () {\n      throw (new Error('UcumXmlDocument is a Singleton.  ' +\n          'Use UcumXmlDocument.getInstance() instead.'));\n    };\n    if (exports)\n      exports.UcumXmlDocument = UcumXmlDocument;\n    UcumXmlDocument.prototype = holdThis;\n\n    let self = this ;\n    UcumXmlDocument.getInstance = function(){return self} ;\n  }\n\n\n  /**\n   * This method controls parsing of the XML into objects used by this\n   * program.  It uses separate methods to parse the prefixes, the\n   * base units, and the units.\n   *\n   * @returns nothing\n   */\n  parseXml() {\n\n    this.parsePrefixes(xmlInput_.childrenNamed(\"prefix\"));\n    this.parseBaseUnits(xmlInput_.childrenNamed(\"base-unit\")) ;\n    this.parseUnitStrings(xmlInput_.childrenNamed(\"unit\")) ;\n\n    // Create the json file of the prefix and unit definitions\n    this.writeJsonFile();\n    this.writeVersionText();\n\n  }\n\n\n  /**\n   * Creates prefix objects from the xml prefix nodes passed in and gets\n   * them added to the prefix tables.\n   *\n   * @params prefixes the array of prefix nodes from the xml file, in the\n   *  order in which the nodes are defined in that file.\n   *\n   * @returns nothing\n   */\n  parsePrefixes(prefixes) {\n\n\n    let plen = prefixes.length ;\n\n    for (let p = 0; p < plen; p++) {\n      let curPfx = prefixes[p];\n      let attrs = {} ;\n\n      attrs[\"code_\"] = curPfx.attr.Code;\n      attrs[\"ciCode_\"] = curPfx.attr.CODE;\n      attrs[\"name_\"] = curPfx.childNamed('name').val;\n      attrs[\"printSymbol_\"] = curPfx.childNamed('printSymbol').val;\n\n      // Set the prefix value.  If there is a <sup> element in the\n      // value node, then this is a base 10 based prefix (10 to the x power).\n      // Set the value to 10 taken to the indicated power.\n      // Otherwise this is not 10 based and the value contains the\n      // actual value for the prefix.\n      let pValNode = curPfx.childNamed('value') ;\n      attrs[\"value_\"] = null;\n      attrs[\"exp_\"] = pValNode.childNamed('sup');\n      if (attrs[\"exp_\"] != null) {\n        attrs[\"exp_\"] = attrs[\"exp_\"].val;\n        attrs[\"value_\"] = Math.pow(10, attrs[\"exp_\"]);\n      }\n      else {\n        attrs[\"value_\"] = pValNode.val;\n        attrs[\"exp_\"] = null;\n      }\n\n      // Make sure the prefix has not already been created.  If it hasn't,\n      // create the prefix object and then add it to the prefix tables.\n      let ptab = PrefixTables.getInstance();\n      if (ptab.isDefined(attrs[\"code_\"])) {\n        throw(new Error('Prefix constructor called for prefix already ' +\n                        `defined; code = ${attrs[\"code_\"]}`));\n      }\n      else {\n        let newPref = new Prefix(attrs);\n        ptab.add(newPref);\n      }\n    }\n  } // end parsePrefixes\n\n\n  /**\n   * Creates base unit objects from the xml nodes passed in and adds\n   * them to the unit tables.\n   *\n   * @params unitNodes the array of base unit nodes from the xml file, in the\n   *  order in which the nodes are defined in that file.  (Order is important\n   *  for all units).\n   *\n   * @returns nothing\n   */\n  parseBaseUnits(unitNodes) {\n    let blen = unitNodes.length ;\n    let utab = UnitTables.getInstance() ;\n    for (let b = 0; b < blen; b++) {\n      let curBUnit = unitNodes[b];\n      let attrs = {} ;\n      attrs['isBase_'] = true ;\n      attrs['name_'] = curBUnit.childNamed('name').val ;\n      attrs['csCode_'] = curBUnit.attr.Code ;\n      attrs['ciCode_'] = curBUnit.attr.CODE ;\n      attrs['property_'] = curBUnit.childNamed('property').val;\n      attrs['variable_'] = curBUnit.attr.dim ;\n      attrs['printSymbol_'] = curBUnit.childNamed('printSymbol').val;\n      attrs['dim_'] = b ;\n      attrs['source_'] = 'UCUM';\n      let newUnit = new Unit(attrs);\n      utab.addUnit(newUnit) ;\n    }\n  } // end parseBaseUnits\n\n\n  /**\n   * Creates non-base unit objects from the xml nodes passed in and adds\n   * them to the unit tables.\n   *\n   * @params unitStrings the array of non-base unit nodes from the xml file, in the\n   *  order in which the nodes are defined in that file.  (Order is important\n   *  for all units).\n   *\n   * @returns nothing\n   */\n  parseUnitStrings(unitStrings) {\n\n    let utab = UnitTables.getInstance() ;\n    let uStrParser = UnitString.getInstance();\n    let stopNow = false ;\n    let alen = unitStrings.length ;\n    for (let a = 0; a < alen && !stopNow; a++) {\n      let haveUnit = true;\n      let curUA = unitStrings[a];\n      let attrs = {};\n      attrs['isBase_'] = false;\n      attrs['source_'] = 'UCUM';\n      attrs['name_'] = curUA.childNamed('name').val;\n      attrs['csCode_'] = curUA.attr.Code;\n      if (curUA.attr.CODE)\n        attrs['ciCode_'] = curUA.attr.CODE;\n      else\n        attrs['ciCode_'] = curUA.attr.Code.toUpperCase();\n      attrs['property_'] = curUA.childNamed('property').val;\n      if (curUA.childNamed('printSymbol')) {\n        let sym = curUA.childNamed('printSymbol') ;\n        let symVal = sym.val;\n        symVal = symVal.replace(/\\n/g, \"\");\n        symVal = symVal.trim();\n        let symI = sym.childNamed('i');\n        if (symI)\n          //symVal = '<i>' + symI.val + '</>';\n          symVal = symI.toString({compressed:true});\n        let sub = sym.childNamed('sub');\n        let sup = sym.childNamed('sup');\n        if (sub)\n          symVal += sub.toString({compressed:true});\n        if (sup)\n          symVal += sup.toString({compressed:true});\n\n        attrs['printSymbol_'] = symVal;\n      }\n      if (curUA.attr.isMetric === \"yes\")\n        attrs['isMetric_'] = true ;\n      else\n        attrs['isMetric_'] = false ;\n      if (curUA.attr.isArbitrary)\n        attrs['isArbitrary_'] = true ;\n      else\n        attrs['isArbitrary_'] = false ;\n      if (curUA.attr.class) {\n        attrs['class_'] = curUA.attr.class;\n      }\n      let valNode = curUA.childNamed('value');\n\n      // Process special units\n      if (curUA.attr.isSpecial) {\n        attrs['isSpecial_'] = curUA.attr.isSpecial === \"yes\";\n        let funcNode = valNode.childNamed('function');\n        attrs['cnv_'] = funcNode.attr.name;\n        attrs['csUnitString_'] = funcNode.attr.Unit;\n        if (attrs['csUnitString_'] === '1') {\n          attrs['baseFactor_'] = 1 ;\n        }\n        else if (attrs['csCode_'] === '[pH]') {\n          attrs['baseFactor_'] = funcNode.attr.value ;\n        }\n        else {\n          let slashPos = attrs['csUnitString_'].indexOf('/');\n          let ar = [];\n\n          // unit string = K/9 or K/4 or m2/s4/Hz\n          if (slashPos >= 0) {\n            ar = attrs['csUnitString_'].split('/');\n          }\n          // unit string = K/9 or K/4\n          if ((slashPos >= 0) && (ar.length === 2)) {\n            attrs['csUnitString_'] = ar[0];\n            attrs['baseFactor_'] = parseFloat(funcNode.attr.value/ar[1]);\n          }\n          // unit string = 10*-5.Pa\n          else if (attrs['csCode_'] === 'B[SPL]') {\n            attrs['baseFactor_'] =  Math.pow(10, -5) * 2 ;\n            attrs['csUnitString_'] = \"Pa\" ;\n          }\n          // unit string = m1/s4/Hz, K, deg, V, mV, uV, nV, W, kW\n          else {\n            attrs['baseFactor_'] = funcNode.attr.value;\n          }\n        } // end if the unit string is not 1\n      } // end if the unit is special\n\n      else {\n        // what I'm calling the unit string is the string that defines the\n        // unit based on other units, e.g., rad2 (radian squared) to define\n        // a steradian unit.  It's not necessarily a proper base unit, although\n        // it ultimately builds on base units.\n        attrs['csUnitString_'] = valNode.attr.Unit;\n        attrs['ciUnitString_'] = valNode.attr.UNIT;\n\n        // what I'm calling the factor here (string and number versions)\n        // is the magnitude used in conjunction with the unit string to define\n        // the new unit, e.g., 3 for a yard that is based in the definition\n        // of feet.\n\n        attrs['baseFactorStr_'] = valNode.attr.value;\n        if (attrs['csCode_'] === '[pi]')\n          attrs['baseFactor_'] = parseFloat(attrs['baseFactorStr_']);\n        else if (valNode.childNamed('sup')) {\n          attrs['baseFactor_'] = parseFloat(valNode.attr.value) ;\n        }\n        else {\n          attrs['baseFactor_'] = valNode.val;\n        }\n      } // end if this is not a special unit\n\n      // Arbitrary units are defined in the UCUM spec as \"not of any\n      // specific dimension and are not commensurable with any other\n      // unit\" (3.2.24).  All arbitrary units in the units definition\n      // XML file currently have a unit string of 1 and a base factor of 1\n      // except the \"international unit\" with a code of [IU].  Its\n      // unit string is the \"international unit\" with a code of [iU],\n      // which is also an arbitrary unit - with a unit string of 1.\n      // So I am assuming [IU] is just another code for the same unit.\n      if (attrs['isArbitrary_'] === true) {\n        attrs['magnitude_'] = 1;\n        attrs['dim_'] = null;\n      }\n\n      // units with class = \"dimless\" don't have dimension arrays.\n      // They're things like the number pi or the number 10 or percent.\n      // Haven't figured out how to handle them yet.\n      else if (attrs['class_'] === 'dimless' ||\n               attrs['csCode_'] === 'mol') {\n        attrs['dim_'] = null ;\n        // figure the magnitude based on the unit string\n        // if it's 1, the magnitude is the value specified for\n        // the base factor, e.g., 3.141592653589793238462 ... for pi\n        if (attrs['csUnitString_'] === '1') {\n          attrs['magnitude_'] = attrs['baseFactor_'];\n        }\n        // else if the unit string starts with 10*, the magnitude is\n        // 10 to the power specified following 10* e.g., unit = 10*-2\n        // for the \"%\" unit.  Except for the mole, which is that\n        // multiplied by the base factor, which in this case (only,\n        // I think) is not 1.\n        else if (attrs['csUnitString_'].substr(0,3) == \"10*\") {\n          let exp = parseInt(attrs['csUnitString_'].substr(3));\n          attrs['magnitude_'] = Math.pow(10, exp) ;\n          if (attrs['baseFactor_'] !== '1') {\n            attrs['magnitude_'] *= attrs['baseFactor_'];\n          }\n        }\n        // else I don't know what it is.\n        else {\n          attrs['defError_'] = true ;\n          console.log('unexpected dimless unit definition, unit code ' +\n                      'is ' + attrs['csCode_']) ;\n        }\n      } // end if this is a unit with class = dimless\n\n      // Handle carat of gold alloys - which doesn't get a dimension\n      //\n      else if (attrs['csCode_'] === \"[car_Au]\") {\n        attrs['magnitude_'] = 1/24 ;\n        attrs['dim_'] = null ;\n      }\n      else {\n\n        // Make sure there's a unit string to base the new unit on.  There\n        // should be, but I'm just checking here to make sure.  And omit\n        // ones with a unit string of 1.  That won't do us any good.\n        if (attrs['csUnitString_'] && attrs['csUnitString_'] !== '1' &&\n            attrs['csUnitString_'] !== 1) {\n\n          haveUnit = false;\n          // Handle some special cases\n          // 1. the Oersted unit, whose string is /[pi].A/m and whose\n          //    value is 250.  Set the baseFactor to 250/[pi] and\n          //    the unit string to A/m\n          if (attrs['csCode_'] === 'Oe') {\n            attrs['baseFactor_'] = 250 / Math.PI;\n            attrs['csUnitString_'] = \"A/m\"\n          }\n          // 2.  Strings that start with '/'.  Set the function to\n          //     the inverse function and trim the '/' off the front\n          //     of the string.\n          else if (attrs['csUnitString_'][0] === '/') {\n            attrs['cnv_'] = 'inv';\n            attrs['csUnitString_'] = attrs['csUnitString_'].substr(1);\n          }\n          // 3.  the Svedberg unit, whose string is 10*-13.s.  Set the\n          //     base factor to 10*-13 and the unit string to s.\n          else if (attrs['csCode_'] === '[S]') {\n            attrs['baseFactor_'] = Math.pow(10, -13);\n            attrs['csUnitString_'] = 's';\n          }\n          // 4.  permeability of vaccuum - code [mu_0], unit given is\n          //     4.[pi].10*-7.N/A2\n          else if (attrs['csCode_'] === '[mu_0]') {\n            attrs['baseFactor_'] = 4 * Math.PI * Math.pow(10, -7);\n            attrs['csUnitString_'] = 'N/A2';\n          }\n          // The unit string parser will use the unit(s) named in the\n          // string to create a new unit with the appropriate dimension\n          // object and magnitude before it's multiplied by the one\n          // specified in the input node.\n          try {\n            let retObj = uStrParser.parseString(attrs['csUnitString_'],\n                                                'validate', false);\n            let ret = retObj[0];\n            let retString = retObj[1];\n            let retMsg = retObj[2];\n\n            // Get the dimension object and magnitude (and adjust by\n            // specified magnitude factor) from the unit created and\n            // assign them to the attributes we'll use to create the\n            // unit for this listing.\n            if (ret) {\n              attrs['dim_'] = ret.getProperty('dim_');\n              let newMag = ret.getProperty('magnitude_');\n              newMag *= attrs['baseFactor_'];\n              attrs['magnitude_'] = newMag;\n              haveUnit = true ;\n            }\n            // if there's no unit, report an error\n            else {\n              attrs['defError_'] = true;\n              console.log(`unit definition error; code = ${attrs['csCode_']}; `+\n                          `msg = ${retMsg}`);\n              attrs['dim_'] = null;\n              attrs['magnitude_'] = null;\n            }\n          }\n          catch(err) {\n            console.log('error thrown from unit parsing code for unit name ' +\n                        attrs['name_'] + '\\n' + err.message);\n            stopNow = true;\n          }\n        } // end if there is a unit string to parse\n      } // end if this is not a dimless unit\n\n      if (haveUnit) {\n        // Now create the unit we want based on the attributes we've\n        // accumulated from the xml input and from figuring the dimension\n        // and magnitude.  Add it to the unit tables\n        let newUnit = new Unit(attrs);\n        utab.addUnit(newUnit);\n\n        // for now, create a list of the units created and save it to a file\n        // for debugging.  This is a temporary file.\n        let uList = utab.printUnits();\n        fs.writeFileSync('UnitsList.txt', uList,\n            {encoding: 'utf8', mode: 0o666, flag: 'w'});\n      } // end if have a parsed unit\n    } // end for a => - to alen\n\n  } // end parseUnitStrings\n\n\n  /**\n   * This writes out the ucumDefs data file, which contains all prefixes and\n   * units (base units and others) read and parsed from the XML file.\n   *\n   * This creates the file in the dist/data directory and appends the\n   * current Date object value to \"ucumDefs\" so that this does not run\n   * into problems with a previously existing file.\n   */\n  writeJsonFile() {\n\n    let licenseText = \"The following data (prefixes and units) was generated \" +\n                      \"by the UCUM LHC code from the UCUM data and selected \" +\n                      \"LOINC combinations of UCUM units.  The license for \" +\n                      \"the UCUM LHC code (demo and library code as well as \" +\n                      \"the combined units) is located at \" +\n                      \"https://github.com/lhncbc/ucum-lhc/blob/LICENSE.md.\" ;\n    let pfxTabs = PrefixTables.getInstance() ;\n    let pfxArray = pfxTabs.allPrefixesByCode();\n    let uTabs = UnitTables.getInstance();\n    let uArray = uTabs.allUnitsByDef();\n\n    let defsHash = { 'license' : licenseText,\n                     'prefixes' : pfxArray,\n                     'units' : uArray};\n    let dt = new Date();\n    jsonfile.writeFileSync('../dist/data/ucumDefs' + dt.valueOf() + '.json',\n                           defsHash,\n                           {spaces: 2, encoding: 'utf8', mode: 0o644, flag: 'w'});\n  } // end writeJsonFile\n\n  /**\n   * This writes out the ucumDefs data file, which contains all prefixes and\n   * units (base units and others) read and parsed from the XML file.\n   *\n   * This creates the file in the dist/data directory and appends the\n   * current Date object value to \"ucumDefs\" so that this does not run\n   * into problems with a previously existing file.\n   */\n  writeVersionText() {\n\n    let rootNode = xmlInput_;\n    let versionNum = rootNode.attr.version;\n    let revNum = rootNode.attr.revision;\n    revNum = revNum.replace('$Revision:', '');\n    revNum = revNum.replace('$', '');\n    revNum = revNum.trim();\n    let rootString = rootNode.toString({compressed:true});\n    let dateIdx = rootString.indexOf('$Date:');\n    rootString = rootString.substr(dateIdx + 6);\n    let nextDolIdx = rootString.indexOf('$');\n    let revDate = rootString.substr(0, nextDolIdx ).replace('$','');\n    revDate = revDate.trim();\n    let versionText = `version ${versionNum}, revision ${revNum}, ` +\n             `dated ${revDate}`;\n\n    fs.writeFileSync('../dist/data/ucumEssenceVersion.txt',\n      versionText, {encoding: 'utf8', mode: 0o644, flag: 'w'});\n  } // end writeVersionText\n\n} // end UcumXmlDocument\n\n\n/**\n *  This function exists ONLY until the original UcumXmlDocument constructor\n *  is called for the first time.  It's defined here in case getInstance\n *  is called before the constructor.   This calls the constructor.\n *\n *  The constructor redefines the getInstance function to return the\n *  singleton UcumXmlDocument object.  This is based on the UnitTables singleton\n *  implementation; see more detail in the UnitTables constructor description.\n *\n *  @return the singleton UcumXmlDocument object.\n */\nUcumXmlDocument.getInstance = function(){\n  return new UcumXmlDocument();\n}\n\n// Perform the first request for the document object, to get the\n// getInstance method set.\nUcumXmlDocument.getInstance();"]}