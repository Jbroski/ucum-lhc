{"version":3,"sources":["../source/unit.js"],"names":["intUtils_","Dimension","require","UcumFunctions","isInteger","UnitTables","Unit","attrs","isBase_","name_","csCode_","ciCode_","property_","magnitude_","undefined","dim_","Array","printSymbol_","class_","isMetric_","variable_","cnv_","cnvPfx_","isSpecial_","isArbitrary_","synonyms_","source_","loincProperty_","category_","guidance_","csUnitString_","ciUnitString_","baseFactorStr_","baseFactor_","defError_","assignZero","vals","key","uKey","charAt","length","hasOwnProperty","Error","retUnit","Object","getOwnPropertyNames","forEach","val","clone","unit2","equals","match","thisAttr","keys","sort","u2Attr","keyLen","k","propertyName","uProp","num","fromUnit","newNum","isNull","fromCnv","fromMag","x","funcs","getInstance","fromFunc","forName","cnvFrom","toFunc","cnvTo","toUnit","convertFrom","f_from","convertCoherent","i","max","getMax","elem","getElementAt","uA","getUnitsByDimension","name","amt","molUnit","molecularWeight","molAmt","tabs","avoNum","getUnitByCode","molesFactor","massUnit","massAmt","mutateCoherent","s","mulVal","toString","_concatStrs","isZero","dimVec_","add","invertString","sub","minus","theString","stringRep","replace","substr","str1","operator","str2","startChar","endChar","_buildOneString","str","ret","isNumericString","includes","p","uStr","uArray","arLen","un","nun","parseInt","Math","pow","uLen","u","uChar","exp","join","mul"],"mappings":"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","file":"unit.js","sourcesContent":["\n/**\n * This class represents one unit of measure.  It includes\n * functions to cover constructor, accessor, and assignment tasks as\n * well as operators to calculate multiplication, division and raising\n * to a power.\n *\n * @author Lee Mericle, based on java version by Gunther Schadow\n *\n */\nvar Dimension = require('./dimension.js').Dimension;\nvar UcumFunctions = require(\"./ucumFunctions.js\").UcumFunctions;\nvar isInteger = require(\"is-integer\");\nvar UnitTables = require(\"./unitTables.js\").UnitTables;\n\nimport * as intUtils_ from \"./ucumInternalUtils.js\";\n\nexport class Unit {\n\n  /**\n   * Constructor.\n   *\n   * @param attrs an optional parameter that may be:\n   *  a string, which is parsed by the unit parser, which creates\n   *  the unit from the parsed string; or\n   *  a hash containing all or some values for the attributes of\n   *  the unit, where the keys are the attribute names, without a\n   *  trailing underscore, e.g., name instead of name_; or\n   *  null, in which case an empty hash is created and used to\n   *  set the values forthe attributes.\n   *  If a hash (empty or not) is used, attributes for which no value\n   *  is specified are assigned a default value.\n   *\n   */\n  constructor(attrs = {}) {\n\n    // Process the attrs hash passed in, which may be empty.\n    // Create and assign values (from the attrs hash or defaults) to all\n    // attributes.  From Class Declarations in Understanding ECMAScript,\n    // https://leanpub.com/understandinges6/read/#leanpub-auto-class-declarations,\n    //   \"Own properties, properties that occur on the instance rather than the\n    //    prototype, can only be created inside of a class constructor or method.\n    //    It's recommended to create all possible own properties inside of the\n    //    constructor function so there's a single place that's responsible for\n    //    all of them.\"\n\n    /*\n     * Flag indicating whether or not this is a base unit\n     */\n    this.isBase_ = attrs['isBase_'] || false ;\n\n    /*\n     * The unit name, e.g., meter\n     */\n    this.name_ = attrs['name_'] || '';\n\n    /*\n     * The unit's case-sensitive code, e.g., m\n     */\n    this.csCode_ = attrs['csCode_'] || '';\n\n    /*\n     * The unit's case-insensitive code, e.g., M\n     */\n    this.ciCode_ = attrs['ciCode_'] || '';\n\n    /*\n     * The unit's property, e.g., length\n     */\n    this.property_ = attrs['property_'] || '';\n\n    /*\n     * The magnitude of the unit, e.g., 3600/3937 for a yard,\n     * where a yard - 3600/3973 * m(eter).  The Dimension\n     * property specifies the meter - which is the unit on which\n     * a yard is based, and this magnitude specifies how to figure\n     * this unit based on the base unit.\n     */\n    this.magnitude_ = attrs['magnitude_'] || 1;\n\n    /*\n     * The Dimension object of the unit\n     */\n    if (attrs['dim_'] === undefined || attrs['dim_'] === null) {\n      this.dim_ = new Dimension();\n    }\n    // When the unit data stored in json format is reloaded, the dimension data\n    // is recognized as a a hash, not as a Dimension object.\n    else if (attrs['dim_']['dimVec_'] !== undefined) {\n      this.dim_ = new Dimension(attrs['dim_']['dimVec_']) ;\n    }\n    else if (attrs['dim_'] instanceof Dimension) {\n      this.dim_ = attrs['dim_'];\n    }\n    else if (attrs['dim_'] instanceof Array || isInteger(attrs['dim_'])) {\n      this.dim_ = new Dimension(attrs['dim_']) ;\n    }\n    else {\n      this.dim_ = new Dimension();\n    }\n    /*\n     * The print symbol of the unit, e.g., m\n     */\n    this.printSymbol_ = attrs['printSymbol_'] || null;\n\n    /*\n     * The class of the unit, where given, e.g., dimless\n     */\n    this.class_ = attrs['class_'] || null;\n\n    /*\n     * A flag indicating whether or not the unit is metric\n     */\n    this.isMetric_ = attrs['isMetric_'] || false;\n\n    /*\n     * The \"variable\" - which I think is used only for base units\n     * The symbol for the variable as used in equations, e.g., s for distance\n     */\n    this.variable_ = attrs['variable_'] || null ;  // comes from 'dim' in XML\n\n    /*\n     * The conversion function\n     */\n    this.cnv_ = attrs['cnv_'] || null;\n\n    /*\n     * The conversion prefix\n     */\n    this.cnvPfx_ = attrs['cnvPfx_'] || 1;\n\n    /*\n     * Flag indicating whether or not this is a \"special\" unit, i.e., is\n     * constructed using a function specific to the measurement, e.g.,\n     * fahrenheit and celsius\n     */\n    this.isSpecial_ = attrs['isSpecial_'] || false ;\n\n    /*\n     * Flag indicating whether or not this is an arbitrary unit\n     */\n    this.isArbitrary_ = attrs['isArbitrary_'] || false;\n\n    /*\n     * Added when added LOINC list of units\n     * synonyms are used by the autocompleter to enhance lookup capabilities\n     * while source says where the unit first shows up.  Current sources are\n     * UCUM - which are units from the unitsofmeasure.org list and LOINC -\n     * which are units from the LOINC data.\n     */\n    this.synonyms_ = attrs['synonyms_'] || null ;\n    this.source_ = attrs['source_'] || null ;\n    this.loincProperty_ = attrs['loincProperty_'] || null;\n    this.category_ = attrs['category_'] || null;\n    this.guidance_ = attrs['guidance_'] || null;\n\n    /*\n     * Used to compute dimension; storing for now until I complete\n     * unit definition parsing\n     */\n    /*\n     * Case sensitive (cs) and case insensitive (ci) base unit strings,\n     * includes exponent and prefix if applicable - specified in\n     * <value Unit=x UNIT=X value=\"nnn\">nnn</value> -- the unit part --\n     * in the ucum-essence.xml file, and may be specified by a user\n     * when requesting conversion or validation of a unit string.  The\n     * magnitude (base factor) is used with this to determine the new unit.\n     * For example, a Newton (unit code N) is created from the string\n     * kg.m/s2, and the value of 1 (base factor defined below). An hour\n     * (unit code h) is created from the unit min (minute) with a value\n     * of 60.\n     */\n    this.csUnitString_ = attrs['csUnitString_'] || null ;\n    this.ciUnitString_ = attrs['ciUnitString_'] || null ;\n\n    /*\n     * String and numeric versions of factor applied to unit specified in\n     * <value Unit=x UNIT=X value=\"nnn\">nnn</value> -- the value part\n     */\n    this.baseFactorStr_ = attrs['baseFactorStr_'] || null;\n    this.baseFactor_ = attrs['baseFactor_'] || null;\n\n    /*\n     * Flag used to indicate units where the definition process failed\n     * when parsing units from the official units definitions file\n     * (currently using the ucum-essence.xml file).  We keep these\n     * so that we can use them to at least validate them as valid\n     * units, but we don't try to convert them.   This is temporary\n     * and only to account for instances where the code does not\n     * take into account various special cases in the xml file.\n     *\n     * This is NOT used when trying to validate a unit string\n     * submitted during a conversion or validation attempt.\n     */\n    this.defError_ = attrs['defError_'] || false ;\n\n\n  } // end constructor\n\n\n  /**\n   * Assign the unity (= dimensionless unit 1) to this unit.\n   *\n   * @return this unit\n   */\n  assignUnity() {\n    this.name_  = \"\" ;\n    this.magnitude_ = 1 ;\n    if (!this.dim_)\n      this.dim_ = new Dimension();\n    this.dim_.assignZero() ;\n    this.cnv_ = null ;\n    this.cnvPfx_ = 1 ;\n    return this;\n\n  } // end assignUnity\n\n\n  /**\n   * This assigns one or more values, as provided in the hash passed in,\n   * to this unit.\n   *\n   * @param vals hash of values to be assigned to the attributes\n   *        specified by the key(s), which should be the attribute\n   *        name without the trailing underscore, e.g., name instead\n   *        of name_.\n   * @return nothing\n   */\n  assignVals(vals) {\n    for (let key in vals) {\n      let uKey = !(key.charAt(key.length - 1)) === '_' ? key + '_' : key ;\n      if (this.hasOwnProperty(uKey))\n        this[uKey] = vals[key];\n      else\n        throw(new Error(`Parameter error; ${key} is not a property of a Unit`));\n    }\n  } // end assignVals\n\n\n  /**\n   * This creates a clone of this unit.\n   *\n   * @return the clone\n   */\n  clone() {\n    let retUnit = new Unit() ;\n    Object.getOwnPropertyNames(this).forEach(val => {\n      if (val === 'dim_') {\n        if (this['dim_'])\n          retUnit['dim_'] = this['dim_'].clone();\n        else\n          retUnit['dim_'] = null;\n      }\n      else\n        retUnit[val] = this[val];\n    });\n    return retUnit ;\n\n  } // end clone\n\n\n  /**\n   * This assigns all properties of a unit passed to it to this unit.\n   *\n   * @param the unit whose properties are to be assigned to this one.\n   * @return nothing; this unit is updated\n   */\n  assign(unit2) {\n    Object.getOwnPropertyNames(unit2).forEach(val => {\n      if (val === 'dim_') {\n        if (unit2['dim_'])\n          this['dim_'] = unit2['dim_'].clone();\n        else\n          this['dim_'] = null;\n      }\n      else {\n        this[val] = unit2[val];\n      }\n    });\n  } // end assign\n\n\n  /**\n   * This determines whether or not object properties of the unit\n   * passed in are equal to the corresponding properties in this unit.\n   * The following properties are the only ones checked:\n   *   magnitude_, dim_, cnv_ and cnvPfx_\n   *\n   * @param unit2 the unit whose properties are to be checked.\n   * @return boolean indicating whether or not they match\n   */\n  equals(unit2) {\n\n    return (this.magnitude_ === unit2.magnitude_ &&\n            this.cnv_ === unit2.cnv_ &&\n            this.cnvPfx_ === unit2.cnvPfx_ &&\n            ((this.dim_ === null && unit2.dim_ === null) ||\n             this.dim_.equals(unit2.dim_)));\n\n  } // end equals\n\n\n  /**\n   * This method compares every attribute of two objects to determine\n   * if they all match.\n   *\n   * @param unit2 the unit that is to be compared to this unit\n   * @return boolean indicating whether or not every attribute matches\n   */\n  fullEquals(unit2) {\n\n    let match = true ;\n    let thisAttr = Object.keys(this).sort();\n    let u2Attr = Object.keys(unit2).sort();\n\n    let keyLen = thisAttr.length ;\n    match = (keyLen === u2Attr.length);\n\n    // check each attribute.   Dimension objects have to checked using\n    // the equals function of the Dimension class.\n    for (let k = 0; k < keyLen && match; k++) {\n      if (thisAttr[k] === u2Attr[k]) {\n        if (thisAttr[k] === 'dim_')\n          match = this.dim_.equals(unit2.dim_);\n        else\n          match = this[thisAttr[k]] === unit2[thisAttr[k]];\n      }\n      else\n        match = false ;\n    } // end do for each key and attribute\n    return match ;\n  }// end of fullEquals\n\n  /**\n   * This returns the value of the property named by the parameter\n   * passed in.\n   *\n   * @param propertyName name of the property to be returned, with\n   *        or without the trailing underscore.\n   * @return the requested property, if found for this unit\n   * @throws an error if the property is not found for this unit\n   */\n  getProperty(propertyName) {\n    let uProp = propertyName.charAt(propertyName.length - 1) === '_' ? propertyName :\n                                             propertyName + '_' ;\n    return this[uProp] ;\n\n  } // end getProperty\n\n\n  /**\n   * Takes a measurement consisting of a number of units and a unit and returns\n   * the equivalent number of this unit.  So, 15 mL would translate\n   * to 1 tablespoon if this object is a tablespoon.\n   *\n   * Note that the number returned may not be what is normally expected.\n   * For example, converting 10 Celsius units to Fahrenheit would \"normally\"\n   * return a value of 50.   But in this case you'll get back something like\n   * 49.99999999999994.\n   *\n   * If either unit is an arbitrary unit an exception is raised.\n   *\n   * @param num the magnitude for the unit to be translated (e.g. 15 for 15 mL)\n   * @param fromUnit the unit to be translated to one of this type (e.g. a mL unit)\n   *\n   * @return the number of converted units (e.g. 1 for 1 tablespoon)\n   * @throws an error if the dimension of the fromUnit differs from this unit's\n   * dimension\n   */\n  convertFrom(num, fromUnit) {\n    let newNum = 0.0 ;\n\n    if (this.isArbitrary_)\n      throw (new Error(`Attempt to convert arbitrary unit ${this.name_}`));\n    if (fromUnit.isArbitrary_)\n      throw (new Error(`Attempt to convert to arbitrary unit ${fromUnit.name_}`));\n\n    // reject request if both units have dimensions that are not equal\n    if (fromUnit.dim_ && this.dim_ && !(fromUnit.dim_.equals(this.dim_))) {\n      throw(new Error(`Sorry.  ${fromUnit.csCode_} cannot be converted ` +\n                      `to ${this.csCode_}.`));\n    }\n    // reject request if there is a \"from\" dimension but no \"to\" dimension\n    if (fromUnit.dim_ && (!this.dim_ || this.dim_.isNull())) {\n      throw(new Error(`Sorry.  ${fromUnit.csCode_} cannot be converted ` +\n        `to ${this.csCode_}.`));\n    }\n\n    // reject request if there is a \"to\" dimension but no \"from\" dimension\n    if (this.dim_ && (!fromUnit.dim_ || fromUnit.dim_.isNull())) {\n      throw(new Error(`Sorry.  ${fromUnit.csCode_} cannot be converted ` +\n        `to ${this.csCode_}.`));\n    }\n\n    let fromCnv = fromUnit.cnv_ ;\n    let fromMag = fromUnit.magnitude_ ;\n\n    // If the same conversion function is specified for both units, which\n    // includes neither unit having a conversion function, multiply the\n    // \"from\" unit's magnitude by the number passed in and then divide\n    // that result by this unit's magnitude.  Do this for units with\n    // and without dimension vectors.  PROBLEM with 2 non-commensurable\n    // units with no dimension vector or function, e.g., byte to mol\n    if (fromCnv === this.cnv_) {\n      newNum = (num * fromMag) / this.magnitude_;\n    }\n    // else use a function to get the number to be returned\n    else {\n      let x = 0.0 ;\n      let funcs = UcumFunctions.getInstance();\n      if (fromCnv != null) {\n        // turn num * fromUnit.magnitude into its ratio scale equivalent,\n        // e.g., convert Celsius to Kelvin\n        let fromFunc = funcs.forName(fromCnv);\n        x = fromFunc.cnvFrom(num * fromUnit.cnvPfx_) * fromMag;\n        //x = fromFunc.cnvFrom(num * fromMag) * fromUnit.cnvPfx_;\n      }\n      else {\n        x = num * fromMag;\n      }\n\n      if (this.cnv_ != null) {\n        // turn mag * origUnit on ratio scale into a non-ratio unit,\n        // e.g. convert Kelvin to Fahrenheit\n        let toFunc = funcs.forName(this.cnv_);\n        newNum = toFunc.cnvTo(x / this.magnitude_) / this.cnvPfx_;\n      }\n      else {\n        newNum = x / this.magnitude_;\n      }\n    } // end if either unit has a conversion function\n\n    return newNum;\n\n  } // end convertFrom\n\n\n  /**\n   * Takes a number and a target unit and returns the number for a measurement\n   * of this unit that corresponds to the number of the target unit passed in.\n   * So, 1 tablespoon (where this unit represents a tablespoon) would translate\n   * to 15 mL.\n   *\n   * See the note on convertFrom about return values.\n   *\n   * @param mag the magnitude for this unit (e.g. 1 for 1 tablespoon)\n   * @param toUnit the unit to which this unit is to be translated\n   *  (e.g. an mL unit)\n   *\n   * @return the converted number value (e.g. 15 mL)\n   * @throws an error if the dimension of the toUnit differs from this unit's\n   *   dimension\n   */\n  convertTo(num, toUnit) {\n\n    return toUnit.convertFrom(num, this) ;\n\n  } // end convertTo\n\n\n  /**\n   * Takes a given number of this unit returns the number of this unit\n   * if it is converted into a coherent unit.  Does not change this unit.\n   *\n   * If this is a coherent unit already, just gives back the number\n   * passed in.\n   *\n   * @param num the number for the coherent version of this unit\n   * @return the number for the coherent version of this unit\n   */\n  convertCoherent(num) {\n\n    // convert mag' * u' into canonical number * u on ratio scale\n    if(this.cnv_ !== null)\n      num = this.cnv_.f_from(num / this.cnvPfx_) * this.magnitude_;\n\n    return num;\n\n  } // end convertCoherent\n\n\n  /**\n   * Mutates this unit into a coherent unit and converts a given number of\n   * units to the appropriate value for this unit as a coherent unit\n   *\n   * @param num the number for this unit before conversion\n   * @return the number of this unit after conversion\n   * @throws an error if the dimensions differ\n   */\n  mutateCoherent(num) {\n\n    // convert mu' * u' into canonical mu * u on ratio scale\n    num = this.convertCoherent(num) ;\n\n    // mutate to coherent unit\n    this.magnitude_ = 1;\n    this.cnv_ = null;\n    this.cnvPfx_ = 1;\n    this.name_ = \"\";\n\n    // build a name as a term of coherent base units\n    // This is probably ALL WRONG and a HORRIBLE MISTAKE\n    // but until we figure out what the heck the name being\n    // built here really is, it will have to stay.\n    for (let i = 0, max = Dimension.getMax(); i < max; i++) {\n      let elem = this.dim_.getElementAt(i);\n      let uA = UnitTables.getUnitsByDimension(new Dimension(i));\n      if(uA == null)\n        throw(new Error(`Can't find base unit for dimension ${i}`));\n      this.name_ = uA.name + elem;\n    }\n    return num;\n\n  } // end mutateCoherent\n\n\n  /**\n   * Converts a unit expressed in mass/grams to a unit expressed in moles.  The\n   * \"this\" unit is the unit expressed in some form of mass (g, mg, mmg, kg,\n   * whatever) and the target or \"to\" unit - the molUnit parameter - is a unit\n   * expressed in moles - mol, umol, mmol, etc.  The unit expressions surrounding\n   * the moles and mass must be convertible.  No validation of this requirement\n   * is performed.\n   *\n   * @param amt the quantity of this units to be converted\n   * @param molUnit the target/to unit for which the converted # is wanted\n   * @param molecularWeight the molecular weight of the substance for which the\n   *  conversion is being made\n   * @return the number of moles the molUnit after conversion from this unit\n   */\n  convertMassToMol(amt, molUnit, molecularWeight) {\n    // The prefix values that have been applied to this unit, which is the mass\n    // (grams) unit, are reflected in the magnitude.  So the number of moles\n    // represented by this unit equals the number of grams -- amount * magnitude\n    // divided by the molecular Weight\n    let molAmt = (this.magnitude_ * amt)/molecularWeight ;\n    // to translate that to the molUnit get the effect of the prefixes applied\n    // to it.  Since the molUnit's basic magnitude, before prefixes are applied,\n    // is avogadro's number, get that and divide it out of the current magnitude.\n    let tabs = UnitTables.getInstance();\n    let avoNum = tabs.getUnitByCode('mol').magnitude_ ;\n    let molesFactor = molUnit.magnitude_ / avoNum ;\n    // return the molAmt divided by the molesFactor as the number of moles\n    // for the molUnit\n    return molAmt/molesFactor ;\n  }\n\n  /**\n   * Converts a unit expressed in moles to a unit expressed in mass (grams).\n   * The \"this\" unit is the unit expressed in some form of moles, e.g., mol,\n   * umol, mmol, etc., and the target or \"to\" unit is a unit expressed in\n   * some form of mass, e.g., g, mg, mmg, kg, etc.  Any unit expressions\n   * surrounding the moles and mass must be convertible. No validation of this\n   * requirement is performed.\n   *\n   * @param amt the quantity of this units to be converted\n   * @param massUnit the target/to unit for which the converted # is wanted\n   * @param molecularWeight the molecular weight of the substance for which the\n   *  conversion is being made\n   * @return the number of grams the massUnit after conversion from this unit\n   */\n  convertMolToMass(amt, massUnit, molecularWeight) {\n    // A simple mole unit has a magnitude of avogadro's number.  Get that\n    // number now (since not everyone agrees on what it is, and what is\n    // being used in this system might change).\n    let tabs = UnitTables.getInstance();\n    let avoNum = tabs.getUnitByCode('mol').magnitude_ ;\n    // Determine what prefix values (mg or mg/dL, etc.) have been applied to\n    // this unit by dividing the simple mole unit magnitude out of the\n    // current mole unit magnitude.\n    let molesFactor = this.magnitude_ / avoNum ;\n    // The number of grams (mass) is equal to the number of moles (amt)\n    // times the molecular weight.  We also multiply that by the prefix values\n    // applied to the current unit (molesFactor) to get the grams for this\n    // particular unit.\n    let massAmt = (molesFactor * amt) * molecularWeight ;\n    // Finally, we return the mass amount/grams for this particular unit\n    // divided by any effects of prefixes applied to the \"to\" unit, which\n    // is assumed to be some form of a gram unit\n    return massAmt / massUnit.magnitude_ ;\n  }\n\n\n  /**\n   * Mutates this unit into a unit on a ratio scale and converts a specified\n   * number of units to an appropriate value for this converted unit\n   *\n   * @param num the number of this unit before it's converted\n   * @return the magnitude of this unit after it's converted\n   * @throw an error if the dimensions differ\n   */\n  mutateRatio(num) {\n    if (this.cnv_ == null)\n      return this.mutateCoherent(num);\n    else\n      return num;\n\n  } // end mutateRatio\n\n\n  /**\n   * Multiplies this unit with a scalar. Special meaning for\n   * special units so that (0.1*B) is 1 dB.\n   *\n   * This function DOES NOT modify this unit.\n   *\n   * @param s the value by which this unit is to be multiplied\n   * @return a copy this unit multiplied by s\n   * */\n  multiplyThis(s) {\n\n    let retUnit = this.clone() ;\n    if (retUnit.cnv_ != null)\n      retUnit.cnvPfx_ *= s;\n    else\n      retUnit.magnitude_ *= s;\n    let mulVal = s.toString();\n    retUnit.name_ = this._concatStrs(mulVal, '*', this.name_, '[', ']');\n    retUnit.csCode_ = this._concatStrs(mulVal, '.', this.csCode_, '(', ')');\n    retUnit.ciCode_ = this._concatStrs(mulVal, '.', this.ciCode_, '(', ')');\n    retUnit.printSymbol_ = this._concatStrs(mulVal, '.', this.printSymbol_,\n        '(', ')');\n\n    return retUnit;\n\n  } // end multiplyThis\n\n\n  /**\n   * Multiplies this unit with another unit. If one of the\n   * units is a non-ratio unit the other must be dimensionless or\n   * else an exception is thrown.\n   *\n   * If either unit is an arbitrary unit an exception is raised.\n   *\n   * This function does NOT modify this unit\n   * @param unit2 the unit to be multiplied with this one\n   * @return this unit after it is multiplied\n   * @throws an error if one of the units is not on a ratio-scale\n   *         and the other is not dimensionless.\n   */\n  multiplyThese(unit2) {\n\n    var retUnit = this.clone() ;\n\n    if (retUnit.isArbitrary_)\n      throw (new Error(`Attempt to multiply arbitrary unit ${retUnit.name_}`));\n    if (unit2.isArbitrary_)\n      throw (new Error(`Attempt to multiply by arbitrary unit ${unit2.name_}`));\n\n    if (retUnit.cnv_ != null) {\n      if (unit2.cnv_ == null && (!unit2.dim_ || unit2.dim_.isZero()))\n        retUnit.cnvPfx_ *= unit2.magnitude_;\n      else\n        throw (new Error(`Attempt to multiply non-ratio unit ${retUnit.name_} ` +\n          'failed.'));\n    } // end if this unit has a conversion function\n\n    else if (unit2.cnv_ != null) {\n      if (!retUnit.dim_ || retUnit.dim_.isZero()) {\n        //retUnit.assign(unit2);\n        retUnit.cnvPfx_ = unit2.cnvPfx_ * retUnit.magnitude_;\n        retUnit.cnv_ = unit2.cnv_ ;\n      }\n      else\n        throw (new Error(`Attempt to multiply non-ratio unit ${unit2.name_}`));\n    } // end if unit2 has a conversion function\n\n    // else neither unit has a conversion function\n    else {\n      retUnit.magnitude_ *= unit2.magnitude_;\n    } // end if unit2 does not have a conversion function\n\n    // If this.dim_ isn't there, clone the dimension in unit2 - if dimVec_\n    // is a dimension in unit2.dim_; else just transfer it to this dimension\n    if (!retUnit.dim_ || (retUnit.dim_ && !retUnit.dim_.dimVec_)) {\n      if (unit2.dim_)\n        retUnit.dim_ = unit2.dim_.clone();\n      else\n        retUnit.dim_ = unit2.dim_;\n    }\n    // Else this.dim_ is there.  If there is a dimension for unit2,\n    // add it to this one.\n    else if (unit2.dim_ && unit2.dim_ instanceof Dimension) {\n      retUnit.dim_.add(unit2.dim_);\n    }\n\n    // Concatenate the unit info (name, code, etc) for all cases\n    // where the multiplication was performed (an error wasn't thrown)\n    retUnit.name_ = this._concatStrs(retUnit.name_, '*', unit2.name_, '[', ']');\n    retUnit.csCode_ = this._concatStrs(retUnit.csCode_, '.', unit2.csCode_,\n      '(', ')');\n    if (retUnit.ciCode_ && unit2.ciCode_)\n      retUnit.ciCode_ = this._concatStrs(retUnit.ciCode_, '.', unit2.ciCode_,\n        '(', ')');\n    else if (unit2.ciCode_)\n      retUnit.ciCode_ = unit2.ciCode_;\n    retUnit.guidance_ = '';\n    if (retUnit.printSymbol_ && unit2.printSymbol_)\n      retUnit.printSymbol_ = this._concatStrs(retUnit.printSymbol_, '.',\n        unit2.printSymbol_, '(', ')');\n    else if (unit2.printSymbol_)\n      retUnit.printSymbol_ = unit2.printSymbol_;\n\n    return retUnit\n\n  } // end multiplyThese\n\n\n  /**\n   * Divides this unit by another unit. If this unit is not on a ratio\n   * scale an exception is raised. Mutating to a ratio scale unit\n   * is not possible for a unit, only for a measurement.\n   *\n   * If either unit is an arbitrary unit an exception is raised.\n   *\n   * This unit is NOT modified by this function.\n   * @param unit2 the unit by which to divide this one\n   * @return this unit after it is divided by unit2\n   * @throws an error if either of the units is not on a ratio scale.\n   * */\n  divide(unit2) {\n\n    var retUnit = this.clone();\n\n    if (retUnit.isArbitrary_)\n      throw (new Error(`Attempt to divide arbitrary unit ${retUnit.name_}`));\n    if (unit2.isArbitrary_)\n      throw (new Error(`Attempt to divide by arbitrary unit ${unit2.name_}`));\n\n    if (retUnit.cnv_ != null)\n      throw (new Error(`Attempt to divide non-ratio unit ${retUnit.name_}`));\n    if (unit2.cnv_ != null)\n      throw (new Error(`Attempt to divide by non-ratio unit ${unit2.name_}`));\n\n\n    if (retUnit.name_ && unit2.name_)\n      retUnit.name_ = this._concatStrs(retUnit.name_, '/', unit2.name_, '[', ']');\n    else if (unit2.name_)\n      retUnit.name_ = unit2.invertString(unit2.name_);\n\n    retUnit.csCode_ = this._concatStrs(retUnit.csCode_, '/', unit2.csCode_,\n      '(', ')');\n\n    if (retUnit.ciCode_ && unit2.ciCode_)\n      retUnit.ciCode_ = this._concatStrs(retUnit.ciCode_, '/', unit2.ciCode_,\n      '(', ')');\n    else if (unit2.ciCode_)\n      retUnit.ciCode_ = unit2.invertString(unit2.ciCode_) ;\n\n    retUnit.guidance_ = '';\n\n    retUnit.magnitude_ /= unit2.magnitude_;\n\n    if (retUnit.printSymbol_ && unit2.printSymbol_)\n      retUnit.printSymbol_ = this._concatStrs(retUnit.printSymbol_, '/',\n        unit2.printSymbol_, '(', ')');\n    else if (unit2.printSymbol_)\n      retUnit.printSymbol_ = unit2.invertString(unit2.printSymbol_);\n\n    // Continue if unit2 has a dimension object.\n    // If this object has a dimension object, subtract unit2's dim_ object from\n    // this one. The sub method will take care of cases where the dimVec_ arrays\n    // are missing on one or both dim_ objects.\n    if (unit2.dim_) {\n      if (retUnit.dim_) {\n        if (retUnit.dim_.isNull())\n          retUnit.dim_.assignZero();\n        retUnit.dim_ = retUnit.dim_.sub(unit2.dim_);\n      } // end if this.dim_ exists\n\n      // Else if this dim_ object is missing, clone unit2's dim_ object\n      // and give the inverted clone to this unit.\n      else\n        retUnit.dim_ = unit2.dim_.clone().minus();\n    } // end if unit2 has a dimension object\n    return retUnit;\n\n  } // end divide\n\n\n  /**\n   * Invert this unit with respect to multiplication. If this unit is not\n   * on a ratio scale an exception is thrown. Mutating to a ratio scale unit\n   * is not possible for a unit, only for a measurement (the magnitude and\n   * dimension).\n   *\n   *  This unit is modified by this function.\n   * @return this unit after being inverted\n   * @throws and error if this unit is not on a ratio scale\n   */\n  invert() {\n\n    if (this.cnv_ != null)\n      throw (new Error(`Attempt to invert a non-ratio unit - ${this.name_}`));\n\n    this.name_ = this.invertString(this.name_);\n    this.magnitude_ = 1/this.magnitude_ ;\n    this.dim_.minus();\n    return this;\n\n  } // end invert\n\n\n  /**\n   * Inverts a string, where the string is assumed to be a code or a name\n   * of a division operation where the string is the divisor and the dividend\n   * is blank.\n   *\n   * @param the string to be inverted\n   * @return the inverted string\n   */\n  invertString(theString) {\n\n    if (theString.length > 0) {\n      let stringRep = theString.replace('/', \"!\").replace('.', '/').replace(\"!\", '.');\n      switch(stringRep.charAt(0)) {\n        case '.' : theString = stringRep.substr(1); break;\n        case '/' : theString = stringRep; break;\n        default  : theString = \"/\" + stringRep;\n      }\n    }\n    return theString;\n\n  } // end invertString\n\n\n  /**\n   * This function handles concatenation of two strings and an operator.\n   * It's called to build unit data, e.g., unit name, unit code, etc., from\n   * two different units, joined by the specified operator.\n   *\n   * @param str1 the first string to appear in the result\n   * @param operator the operator ('*', '.' or '/') to appear between the strings\n   * @param str2 the second string to appear in the result\n   * @param startChar the starting character to be used, when needed, to\n   *  enclose a string\n   * @param endChar the ending character to be used, when needed, to enclose\n   *  a string\n   * @returns the built string\n   */\n  _concatStrs(str1, operator, str2, startChar, endChar) {\n\n    return this._buildOneString(str1, startChar, endChar) +\n      operator + this._buildOneString(str2, startChar, endChar) ;\n  }\n\n\n  /**\n   * This function handles creation of one string to be included in a\n   * concatenated string.   Basically it checks to see if the string\n   * needs to be enclosed either in parentheses or square brackets.\n   *\n   * The string is enclosed if it is not a number, does not start with\n   * a parenthesis or square bracket, and includes a period, and asterisk,\n   * a slash or a blank space.\n   *\n   * @param str the string\n   * @param startChar starting enclosing character\n   * @param endChar ending enclosing character\n   * @returns the string\n   */\n  _buildOneString(str, startChar, endChar) {\n    let ret = '' ;\n    if (intUtils_.isNumericString(str)) {\n      ret = str;\n    }\n    else {\n      if (str.charAt(0) === '(' || str.charAt(0) === '[') {\n        ret = str;\n      }\n      else if (str.includes('.') || str.includes('/') ||\n               str.includes('*') || str.includes(' ')) {\n        ret = startChar + str + endChar ;\n      }\n      else {\n        ret = str ;\n      }\n    }\n    return ret ;\n  }\n\n\n  /**\n   * Raises the unit to a power.  For example\n   *  kg.m/s2 raised to the -2 power would be kg-2.m-2/s-4\n   *\n   * If this unit is not on a ratio scale an error is thrown. Mutating\n   * to a ratio scale unit is not possible for a unit, only for a\n   * measurement (magnitude and dimension).\n   *\n   * This is based on the pow method in Gunter Schadow's java version,\n   * although it uses javascript capabilities to simplify the processing.\n   *\n   * This unit is modified by this function\n   *\n   * @param p the power to with this unit is to be raise\n   * @return this unit after it is raised\n   * @throws an error if this unit is not on a ratio scale.\n   */\n  power(p) {\n\n    if (this.cnv_ != null)\n      throw (new Error(`Attempt to raise a non-ratio unit, ${this.name_}, ` +\n                       'to a power.'));\n\n    //this.name_ = UnitString.pow(this.name_, p);\n    // the above line is replaced with the code below, as the pow method\n    // never actually existing in the UnitString class.  (Tried to use\n    // Schadow java code but this way ended up being a lot easier).\n    let uStr = this.csCode_ ;\n    let uArray = uStr.match(/([./]|[^./]+)/g) ;\n    let arLen = uArray.length;\n\n    for (let i = 0; i < arLen; i++) {\n      let un = uArray[i] ;\n      if (un !== '/' && un !== '.') {\n        let nun = parseInt(un);\n        if (isInteger(nun))\n          uArray[i] = (Math.pow(nun, p).toString());\n        else {\n          let uLen = un.length ;\n          for (let u = uLen - 1; u >= 0; u--) {\n            let uChar = parseInt(un[u]);\n            if (!isInteger(uChar)) {\n              if (un[u] === '-' || un[u] === '+') {\n                u--;\n              }\n              if (u < uLen - 1) {\n                let exp = parseInt(un.substr(u));\n                exp = Math.pow(exp, p);\n                uArray[i] = un.substr(0, u) + exp.toString();\n                u = -1;\n              }\n              else {\n                uArray[i] += p.toString();\n                u = -1;\n              } // end if there are/aren't some numbers at the end\n              u = -1;\n            } // end if this character is not a number\n          } // end searching backwards for start of exponent\n        } // end if this element is not a number\n      } // end if the current element is not an operator\n    } // end do for each element of the units array\n\n    // reassemble the updated units array to a string\n    this.csCode_ = uArray.join('');\n\n    this.magnitude_ = Math.pow(this.magnitude_, p);\n    if (this.dim_) {\n      this.dim_.mul(p);\n    }\n    return this;\n\n  } // end power\n\n\n} // end Unit class\n"]}