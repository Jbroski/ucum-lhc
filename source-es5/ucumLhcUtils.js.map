{"version":3,"sources":["../source/ucumLhcUtils.js"],"names":["intUtils_","Ucum","require","UcumJsonDefs","UnitTables","UnitString","Unit","Prefix","fs","UcumLhcUtils","getInstance","unitsCount","uDefs","loadJsonDefs","uStrParser_","use","undefined","useHTMLInMessages","useBraceMsgForEachString","uStr","suggest","valConv","resp","getSpecifiedUnit","theUnit","retObj","csCode_","name_","guidance_","fromUnitCode","fromVal","toUnitCode","molecularWeight","returnObj","trim","push","isNaN","isNumericString","fromUnit","parseResp","concat","toUnit","includes","Error","convertMolToMass","convertMassToMol","convertFrom","err","message","theSyn","getSynonyms","uName","utab","getUnitByCode","parseString","console","log","unshift","fromName","retMsg","commUnits","length","dimVec","fromDim","getProperty","getUnitsByDimension","uct","uList","printUnits","writeFileSync","encoding","mode","flag"],"mappings":"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","file":"ucumLhcUtils.js","sourcesContent":["/**\n * This class provides a single point of access to the LHC UCUM utilities\n *\n * @author Lee Mericle\n *\n */\nvar Ucum = require('./config.js').Ucum;\nvar UcumJsonDefs = require('./ucumJsonDefs.js').UcumJsonDefs ;\nvar UnitTables = require('./unitTables.js').UnitTables;\nvar UnitString = require('./unitString.js').UnitString;\nvar Unit = require('./unit.js').Unit;\nvar Prefix = require('./prefix.js').Prefix;\nvar fs = require('fs');\n\nimport * as intUtils_ from \"./ucumInternalUtils.js\";\n\n/**\n * UCUM external utilities class\n */\nexport class UcumLhcUtils {\n\n  /**\n   * Constructor.  This loads the json prefix and unit definitions if\n   * they haven't been loaded already and creates itself as a singleton object.\n   *\n   */\n  constructor() {\n\n      if (UnitTables.getInstance().unitsCount() === 0) {\n\n        // Load the prefix and unit objects\n        let uDefs = UcumJsonDefs.getInstance();\n        uDefs.loadJsonDefs();\n      }\n\n      // Get the UnitString parser that will be used with this instance\n      // of the LHC Utilities\n      this.uStrParser_ = UnitString.getInstance();\n\n  } // end constructor\n\n\n  /**\n   * This method calls the useHTMLInMessages method on the UnitString\n   * object.  It should be called by web applications that use\n   * these utilities.\n   *\n   * @param use flag indicating whether or not to use the braces message;\n   *  defaults to true\n   */\n  useHTMLInMessages(use) {\n    if (use === undefined)\n      use = true ;\n    this.uStrParser_.useHTMLInMessages(use);\n  }\n\n\n  /**\n   * This method calls the useBraceMsgForEachString method on the UnitString\n   * object.  It should be called by web applications where unit\n   * strings are validated individually (as opposed to validating a whole\n   * file of unit strings).\n   *\n   * @param use flag indicating whether or not to use the braces message;\n   *  defaults to true\n   */\n  useBraceMsgForEachString(use) {\n    if (use === undefined)\n      use = true ;\n    this.uStrParser_.useBraceMsgForEachString(use);\n  }\n\n\n  /**\n   * This method validates a unit string.  It first checks to see if the\n   * string passed in is a unit code that is found in the unit codes table.\n   * If it is not found it parses the string to see if it resolves to a\n   * valid unit string.\n   *\n   * If a valid unit cannot be found, the string is tested for some common\n   * errors, such as missing brackets or a missing multiplication operator.\n   * If found, the error is reported in the messages array that is returned.\n   *\n   * If a valid unit cannot be found and an error cannot be discerned, this\n   * may return, if requested, a list of suggested units in the messages\n   * array that is returned.  Suggestions are based on matching the expression\n   * with unit names and synonyms.\n   *\n   * @param uStr the string to be validated\n   * @param suggest a boolean to indicate whether or not suggestions are\n   *  requested for a string that cannot be resolved to a valid unit;\n   *  true indicates suggestions are wanted; false indicates they are not,\n   *  and is the default if the parameter is not specified;\n   * @param valConv a string indicating if this validation request was initiated\n   *  by a validation task ('validate') or a conversion task ('convert'),\n   *  used only for the demo code, and the default is 'Validator' if the\n   *  parameter is not specified;\n   * @returns an object with five properties:\n   *  'status' will be 'valid' (the uStr is a valid UCUM code), 'invalid'\n   *     (the uStr is not a valid UCUM code, and substitutions or\n   *     suggestions may or may not be returned, depending on what was\n   *     requested and found); or 'error' (an input or programming error\n   *     occurred);\n   *  'ucumCode' the valid ucum code, which may differ from what was passed\n   *    in (e.g., if 'Gauss' is passed in, this will contain 'G') OR null if\n   *    the string was flagged as invalid or an error occurred;\n   *  'msg' is an array of one or more messages, if the string is invalid or\n   *        an error occurred, indicating the problem, or an explanation of a\n   *        substitution such as the substitution of 'G' for 'Gauss', or\n   *        an empty array if no messages were generated;\n   *  'unit' which is null if no unit is found, or a hash for a unit found:\n   *    'code' is the unit's ucum code (G in the above example;\n   *    'name' is the unit's name (Gauss in the above example); and\n   *    'guidance' is the unit's guidance/description data; and\n   *  'suggestions' if suggestions were requested and found, this is an array\n   *     of one or more hash objects.  Each hash contains three elements:\n   *     'msg' which is a message indicating what part of the uStr input\n   *        parameter the suggestions are for;\n   *     'invalidUnit' which is the unit expression the suggestions are\n   *        for; and\n   *     'units' which is an array of data for each suggested unit found.\n   *        Each array will contain the unit code, the unit name and the\n   *        unit guidance (if any).\n   *     If no suggestions were requested and found, this property is not\n   *     returned.\n   */\n  validateUnitString(uStr, suggest, valConv) {\n\n    if (suggest === undefined)\n      suggest = false ;\n\n    if (valConv === undefined)\n      valConv = 'validate' ;\n\n    let resp = this.getSpecifiedUnit(uStr, valConv, suggest);\n    let theUnit = resp['unit'];\n    let retObj = {};\n    if (!theUnit) {\n      retObj = {'status': (!resp['origString'] || resp['origString'] === null) ?\n                           'error' : 'invalid',\n                'ucumCode': null};\n    }\n    else {\n      retObj = {'status': resp['origString'] === uStr ? 'valid': 'invalid',\n                'ucumCode': resp['origString'],\n                'unit': {'code': theUnit.csCode_,\n                         'name': theUnit.name_,\n                         'guidance': theUnit.guidance_ }};\n    }\n    if (resp['suggestions']) {\n      retObj['suggestions'] = resp['suggestions'];\n    }\n    retObj['msg'] = resp['retMsg'];\n    return retObj;\n\n  } // end validateUnitString\n\n\n  /**\n   * This method converts one unit to another\n   *\n   * @param fromUnitCode the unit code/expression/string of the unit to be converted\n   * @param fromVal the number of \"from\" units to be converted to \"to\" units\n   * @param toUnitCode the unit code/expression/string of the unit that the from\n   *  field is to be converted to\n   * @param suggest a boolean to indicate whether or not suggestions are\n   *  requested for a string that cannot be resolved to a valid unit;\n   *  true indicates suggestions are wanted; false indicates they are not,\n   *  and is the default if the parameter is not specified;\n   * @param molecularWeight the molecular weight of the substance in question\n   *  when a conversion is being requested from mass to moles and vice versa.\n   *  This is required when one of the units represents a value in moles.  It is\n   *  ignored if neither unit includes a measurement in moles.\n   * @returns a hash with six elements:\n   *  'status' that will be: 'succeeded' if the conversion was successfully\n   *     calculated; 'failed' if the conversion could not be made, e.g., if\n   *     the units are not commensurable; or 'error' if an error occurred;\n   *  'toVal' the numeric value indicating the conversion amount, or null\n   *     if the conversion failed (e.g., if the units are not commensurable);\n   *  'msg' is an array message, if the string is invalid or an error occurred,\n   *        indicating the problem, or an explanation of a substitution such as\n   *        the substitution of 'G' for 'Gauss', or an empty array if no\n   *        messages were generated;\n   *  'suggestions' if suggestions were requested and found, this is a hash\n   *     that contains at most two elements:\n   *     'from' which, if the fromUnitCode input parameter or one or more of\n   *       its components could not be found, is an array one or more hash\n   *       objects.  Each hash contains three elements:\n   *         'msg' which is a message indicating what unit expression the\n   *            suggestions are for;\n   *         'invalidUnit' which is the unit expression the suggestions\n   *            are for; and\n   *         'units' which is an array of data for each suggested unit found.\n   *            Each array will contain the unit code, the unit name and the\n   *            unit guidance (if any).\n   *       If no suggestions were found for the fromUnitCode this element\n   *       will not be included.\n   *     'to' which, if the \"to\" unit expression or one or more of its\n   *       components could not be found, is an array one or more hash objects.  Each hash\n   *       contains three elements:\n   *         'msg' which is a message indicating what toUnitCode input\n   *            parameter the suggestions are for;\n   *         'invalidUnit' which is the unit expression the suggestions\n   *            are for; and\n   *         'units' which is an array of data for each suggested unit found.\n   *            Each array will contain the unit code, the unit name and the\n   *            unit guidance (if any).\n   *       If no suggestions were found for the toUnitCode this element\n   *       will not be included.\n   *    No 'suggestions' element will be included in the returned hash\n   *    object if none were found, whether or not they were requested.\n   *  'fromUnit' the unit object for the fromUnitCode passed in; returned\n   *     in case it's needed for additional data from the object; and\n   *  'toUnit' the unit object for the toUnitCode passed in; returned\n   *     in case it's needed for additional data from the object.\n   */\n  convertUnitTo(fromUnitCode, fromVal, toUnitCode, suggest, molecularWeight) {\n    if (suggest === undefined)\n      suggest = false ;\n\n    if (molecularWeight === undefined)\n      molecularWeight = null ;\n\n    let returnObj = {'status' : 'failed',\n                     'toVal' : null,\n                     'msg' : []} ;\n\n    if (fromUnitCode) {\n      fromUnitCode = fromUnitCode.trim();\n    }\n    if (!fromUnitCode || fromUnitCode == '') {\n      returnObj['status'] = 'error';\n      returnObj['msg'].push('No \"from\" unit expression specified.');\n    }\n    if (fromVal === null || isNaN(fromVal) || (typeof fromVal !== 'number' &&\n        !intUtils_.isNumericString(fromVal))) {\n      returnObj['status'] = 'error';\n      returnObj['msg'].push('No \"from\" value, or an invalid \"from\" value, ' +\n                         'was specified.');\n    }\n    if (toUnitCode) {\n      toUnitCode = toUnitCode.trim();\n    }\n    if (!toUnitCode || toUnitCode == '') {\n      returnObj['status'] = 'error';\n      returnObj['msg'].push('No \"to\" unit expression specified.');\n    }\n    if (returnObj['status'] !== 'error') {\n      try {\n        let fromUnit = null;\n\n        let parseResp = this.getSpecifiedUnit(fromUnitCode, 'convert', suggest);\n        fromUnit = parseResp['unit'];\n        if (parseResp['retMsg'])\n          returnObj['msg'] = returnObj['msg'].concat(parseResp['retMsg']);\n        if (parseResp['suggestions']) {\n          returnObj['suggestions'] = {};\n          returnObj['suggestions']['from'] = parseResp['suggestions'];\n        }\n        if (!fromUnit) {\n          returnObj['msg'].push(`Unable to find a unit for ${fromUnitCode}, ` +\n            `so no conversion could be performed.`);\n        }\n\n        let toUnit = null;\n        parseResp = this.getSpecifiedUnit(toUnitCode, 'convert', suggest);\n        toUnit = parseResp['unit'];\n        if (parseResp['retMsg'])\n          returnObj['msg'] = returnObj['msg'].concat(parseResp['retMsg']);\n        if (parseResp['suggestions']) {\n          if (!returnObj['suggestions'])\n            returnObj['suggestions'] = {} ;\n          returnObj['suggestions']['to'] = parseResp['suggestions'];\n        }\n        if (!toUnit) {\n          returnObj['msg'].push(`Unable to find a unit for ${toUnitCode}, ` +\n                                `so no conversion could be performed.`);\n        }\n\n        if (fromUnit && toUnit) {\n          try {\n            if ((fromUnit.csCode_.includes('mol') && !molecularWeight) ||\n                (toUnit.csCode_.includes('mol') && !molecularWeight))\n              throw (new Error('Molecular weight must be supplied for ' +\n                'conversion between mass and moles; none was supplied.'));\n            if (molecularWeight) {\n              if (fromUnit.csCode_.includes('mol')){\n                returnObj['toVal'] =\n                  fromUnit.convertMolToMass(fromVal, toUnit, molecularWeight)\n              }\n              else {\n                returnObj['toVal'] =\n                  fromUnit.convertMassToMol(fromVal, toUnit, molecularWeight)\n              }\n            }\n            else {\n              returnObj['toVal'] = toUnit.convertFrom(fromVal, fromUnit);\n\n            }\n            returnObj['status'] = 'succeeded';\n            returnObj['fromUnit'] = fromUnit;\n            returnObj['toUnit'] = toUnit;\n          }\n          catch (err) {\n            returnObj['status'] = 'failed';\n            returnObj['msg'].push(err.message);\n          }\n        }  // end if we have the from and to units\n      }\n      catch (err) {\n        returnObj['status'] = 'error';\n        returnObj['msg'].push(err.message);\n      }\n    }\n\n    return returnObj ;\n\n  } // end convertUnitTo\n\n\n  /**\n   * This method accepts a term and looks for units that include it as\n   * a synonym - or that include the term in its name.\n   *\n   * @param theSyn the term to search for\n   * @returns a hash with up to three elements:\n   *  'status' contains the status of the request, which can be 'error',\n   *    'failed' or succeeded';\n   *  'msg' which contains a message for an error or if no units were found; and\n   *  'units' which is an array that contains one hash for each unit found:\n   *    'code' is the unit's csCode_\n   *    'name' is the unit's name_\n   *    'guidance' is the unit's guidance_\n   *\n   */\n  checkSynonyms(theSyn) {\n    let retObj = {} ;\n    if (theSyn === undefined || theSyn === null) {\n      retObj['status'] = 'error';\n      retObj['msg'] = 'No term specified for synonym search.'\n    }\n    else {\n      retObj = intUtils_.getSynonyms(theSyn);\n    } // end if a search synonym was supplied\n\n    return retObj ;\n\n  } // end checkSynonyms\n\n\n  /**\n   * This method parses a unit string to get (or try to get) the unit\n   * represented by the string.  It returns an error message if no string was specified\n   * or if any errors were encountered trying to get the unit.\n   *\n   * @param uName the expression/string representing the unit\n   * @param valConv indicates what type of request this is for - a request to\n   *  validate (pass in 'validate') or a request to convert (pass in 'convert')\n   * @param suggest a boolean to indicate whether or not suggestions are\n   *  requested for a string that cannot be resolved to a valid unit;\n   *  true indicates suggestions are wanted; false indicates they are not,\n   *  and is the default if the parameter is not specified;\n   * @returns a hash containing:\n   *   'unit' the unit object (or null if there were problems creating the\n   *     unit);\n   *   'origString' the possibly updated unit string passed in;\n   *   'retMsg' an array of user messages (informational, error or warning) if\n   *     any were generated (IF any were generated, otherwise will be an\n   *     empty array); and\n   *  'suggestions' is an array of 1 or more hash objects.  Each hash\n   *     contains three elements:\n   *       'msg' which is a message indicating what unit expression the\n   *          suggestions are for;\n   *       'invalidUnit' which is the unit expression the suggestions are\n   *          for; and\n   *       'units' which is an array of data for each suggested unit found.\n   *          Each array will contain the unit code, the unit name and the\n   *          unit guidance (if any).\n   *   The return hash will not contain a suggestions array if a valid unit\n   *   was found or if suggestions were not requested and found.\n   */\n  getSpecifiedUnit(uName, valConv, suggest) {\n\n    if (suggest === undefined)\n      suggest = false ;\n\n    let retObj = {};\n    retObj['retMsg'] = [];\n\n    if (!uName) {\n      retObj['retMsg'].push('No unit string specified.');\n    }\n    else {\n      let utab = UnitTables.getInstance();\n      uName = uName.trim();\n\n      // go ahead and just try using the name as the code.  This may or may not\n      // work, but if it does, it cuts out a lot of parsing.\n      let theUnit = utab.getUnitByCode(uName);\n\n      // If we found it, set the returned unit string to what was passed in;\n      // otherwise try parsing as a unit string\n      if (theUnit) {\n        retObj['unit'] = theUnit ;\n        retObj['origString'] = uName;\n      }\n      else {\n        try {\n          let resp = this.uStrParser_.parseString(uName, valConv, suggest);\n          retObj['unit'] = resp[0];\n          retObj['origString'] = resp[1];\n          if (resp[2])\n            retObj['retMsg'] = resp[2];\n          retObj['suggestions'] = resp[3];\n        }\n        catch (err) {\n          console.log(`Unit requested for unit string ${uName}.` +\n            'request unsuccessful; error thrown = ' + err.message);\n            retObj['retMsg'].unshift(`${uName} is not a valid unit.  ` +\n                                     `${err.message}`);\n        }\n      } // end if the unit was not found as a unit name\n    } // end if a unit expression was specified\n\n    return retObj;\n\n  } // end getSpecifiedUnit\n\n\n  /**\n   * This method retrieves a list of units commensurable, i.e., that can be\n   * converted from and to, a specified unit.  Returns an error if the \"from\"\n   * unit cannot be found.\n   *\n   * @param fromName the name/unit string of the \"from\" unit\n   * @returns an array containing two elements;\n   *   first element is the list of commensurable units if any were found\n   *   second element is an error message if the \"from\" unit is not found\n   */\n  commensurablesList(fromName) {\n\n    let retMsg = [];\n    let commUnits = null ;\n    let parseResp = this.getSpecifiedUnit(fromName, 'validate', false);\n    let fromUnit = parseResp['unit'];\n    if (parseResp['retMsg'].length > 0)\n      retMsg = parseResp['retMsg'] ;\n    if (!fromUnit) {\n      retMsg.push(`Could not find unit ${fromName}.`);\n    }\n    else {\n      let dimVec = null ;\n      let fromDim = fromUnit.getProperty('dim_');\n      if (!fromDim) {\n        retMsg.push('No commensurable units were found for ' + fromName) ;\n      }\n      else {\n        try {\n          dimVec = fromDim.getProperty('dimVec_');\n        }\n        catch (err) {\n          retMsg.push(err.message);\n          if (err.message ===\n            \"Dimension does not have requested property(dimVec_)\")\n            dimVec = null;\n        }\n        if (dimVec) {\n          let utab = UnitTables.getInstance();\n          commUnits = utab.getUnitsByDimension(dimVec);\n        }\n      } // end if the from unit has a dimension vector\n    } // end if we found a \"from\" unit\n    return [commUnits , retMsg];\n  } // end commensurablesList\n\n\n  /**\n   * Creates a file containing a list of the units.  The file is created\n   * in the current directory.\n   */\n  printUnits() {\n\n    // for now, create a list of the units created and save it to a file\n    // for debugging.  This is a temporary file.\n    let utab = UnitTables.getInstance();\n    let uct = utab.unitsCount();\n    let uList = utab.printUnits(true);\n    fs.writeFileSync('JsonUnitsList.txt', uList,\n        {encoding: 'utf8', mode: 0o666, flag: 'w'} );\n  }\n\n\n} // end UcumLhcUtils class\n\n\n/**\n *  This function exists ONLY until the original UcumLhcUtils constructor\n *  is called for the first time.  It's defined here in case getInstance\n *  is called before the constructor.   This calls the constructor.\n *\n *  The constructor redefines the getInstance function to return the\n *  singleton UcumLhcUtils object.  This is based on the UnitTables singleton\n *  implementation; see more detail in the UnitTables constructor description.\n *\n *  NO LONGER TRUE - not implemented as a singleton.  This method retained to\n *  avoid problems with calls to it that exist throughout the code.\n *\n *  @return the (formerly singleton) UcumLhcUtils object.\n */\nUcumLhcUtils.getInstance = function(){\n  return new UcumLhcUtils();\n} ;\n\n\n\n\n"]}