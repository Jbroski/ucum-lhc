{"version":3,"sources":["../source/unitString.js"],"names":["intUtils_","Ucum","require","Unit","UnitTables","PrefixTables","UnitString","utabs_","getInstance","pfxTabs_","openEmph_","closeEmph_","bracesMsg_","parensFlag_","pFlagLen_","length","braceFlag_","bFlagLen_","vcMsgStart_","vcMsgEnd_","retMsg_","parensUnits_","annotations_","suggestions","use","undefined","openEmphHTML_","closeEmphHTML_","uStr","valConv","suggest","trim","Error","valMsgStart_","valMsgEnd_","cnvMsgStart_","cnvMsgEnd_","suggestions_","origString","retObj","_getAnnotations","endProcessing","sUnit","specUnits_","includes","replace","indexOf","_parseTheString","finalUnit","isNumericString","parensResp","_processParens","uArray","mkUArray","_makeUnitsArray","uLen","u1","curCode","Number","parenUnit","_getParensUnit","uRet","_makeUnit","push","_performUnitArithmetic","uString","openBrace","closeBrace","substr","braceStr","substring","aIdx","toString","uStrArray","uStrAryPos","stopProcessing","pu","trimmedCt","openCt","closeCt","openPos","closePos","theMsg","c","parseResp","join","uArray1","match","startNumCheck","unshift","numRes","dispVal","parensback","op","un","n","theOp","validOps_","numRes2","invalidString","parensString","nextParens","parensStr","pStr","retAry","retUnit","befAnnoText","aftAnnoText","psIdx","befText","peIdx","lastIndexOf","aftText","pNumText","csCode_","nMag","getProperty","assignVals","annoRet","_getAnnoText","suggestStat","_getSuggestions","power","asIdx","startText","aeIdx","endText","idx","idxNum","getSynonyms","suggSet","synLen","s","unit","unitArray","uCode","getUnitByCode","clone","getAnnoRet","_getUnitWithAnnotation","tryCode","ciCode_","addBrackets","name_","retUnitAry","getUnitByName","mString","dupMsg","r","rStr","RegExp","res","origCode","origUnit","exp","pfxCode","pfxObj","pfxVal","pfxExp","codeAndExp","_isCodeWithExponent","charAt","getPrefixByCode","getValue","getExp","pCodeLen","guidance_","theDim","theMag","theName","theCiCode","thePrintSymbol","parseInt","expMul","mul","Math","pow","cnv_","theCode","getName","getCiCode","getPrintSymbol","expStr","annoText","msgLen","tryBrackets","mkUnitRet","pop","u2","nextUnit","msgString","thisOp","isDiv","divide","multiplyThese","err","message","ret"],"mappings":";;;;;;;;;;;AASA;;IAAYA,S;;;;;;;;AATZ;;;;AAIA,IAAIC,OAAOC,QAAQ,aAAR,EAAuBD,IAAlC;AACA,IAAIE,OAAOD,QAAQ,WAAR,EAAqBC,IAAhC;AACA,IAAIC,aAAaF,QAAQ,iBAAR,EAA2BE,UAA5C;AACA,IAAIC,eAAeH,QAAQ,mBAAR,EAA6BG,YAAhD;;IAIaC,U,WAAAA,U;;AAEX;;;AAGA,wBAAc;AAAA;;AAEZ;AACA,SAAKC,MAAL,GAAcH,WAAWI,WAAX,EAAd;AACA,SAAKC,QAAL,GAAgBJ,aAAaG,WAAb,EAAhB;;AAEA;AACA;AACA;AACA,SAAKE,SAAL,GAAiBT,KAAKS,SAAtB;AACA,SAAKC,UAAL,GAAkBV,KAAKU,UAAvB;;AAEA;AACA;AACA;AACA;AACA;AACA,SAAKC,UAAL,GAAkB,EAAlB;;AAEA;AACA;AACA,SAAKC,WAAL,GAAmB,oBAAnB,CArBY,CAqB6B;AACzC,SAAKC,SAAL,GAAiB,KAAKD,WAAL,CAAiBE,MAAlC;AACA,SAAKC,UAAL,GAAkB,oBAAlB,CAvBY,CAuB4B;AACxC,SAAKC,SAAL,GAAiB,KAAKD,UAAL,CAAgBD,MAAjC;;AAEA;AACA;AACA,SAAKG,WAAL,GAAmB,IAAnB;AACA,SAAKC,SAAL,GAAiB,IAAjB;;AAEA;AACA;;AAEA;AACA,SAAKC,OAAL,GAAe,EAAf;;AAEA;AACA,SAAKC,YAAL,GAAoB,EAApB;;AAEA;AACA,SAAKC,YAAL,GAAoB,EAApB;;AAEA;AACA,SAAKC,WAAL,GAAmB,EAAnB;AAED,G,CAAC;;;AAGF;;;;;;;;;;;sCAOkBC,G,EAAK;AACrB,UAAIA,QAAQC,SAAR,IAAqBD,GAAzB,EAA8B;AAC5B,aAAKd,SAAL,GAAiBT,KAAKyB,aAAtB;AACA,aAAKf,UAAL,GAAkBV,KAAK0B,cAAvB;AACD,OAHD,MAIK;AACH,aAAKjB,SAAL,GAAiBT,KAAKS,SAAtB;AACA,aAAKC,UAAL,GAAkBV,KAAKU,UAAvB;AACD;AACF,K,CAAC;;;AAGF;;;;;;;;;;6CAOyBa,G,EAAK;AAC5B,UAAIA,QAAQC,SAAR,IAAqBD,GAAzB,EACE,KAAKZ,UAAL,GAAkBX,KAAKW,UAAvB,CADF,KAGE,KAAKA,UAAL,GAAkB,EAAlB;AACH;;AAGD;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;gCAsCYgB,I,EAAMC,O,EAASC,O,EAAS;;AAElCF,aAAOA,KAAKG,IAAL,EAAP;AACA;AACA,UAAIH,SAAS,EAAT,IAAeA,SAAS,IAA5B,EAAkC;AAChC,cAAO,IAAII,KAAJ,CAAU,mDAAV,CAAP;AACD;;AAED,UAAIH,YAAY,UAAhB,EAA4B;AAC1B,aAAKX,WAAL,GAAmBjB,KAAKgC,YAAxB;AACA,aAAKd,SAAL,GAAiBlB,KAAKiC,UAAtB;AACD,OAHD,MAIK;AACH,aAAKhB,WAAL,GAAmBjB,KAAKkC,YAAxB;AACA,aAAKhB,SAAL,GAAiBlB,KAAKmC,UAAtB;AACD;;AAED,UAAIN,YAAYL,SAAZ,IAAyBK,YAAY,KAAzC,EAAgD;AAC9C,aAAKO,YAAL,GAAoB,IAApB;AACD,OAFD,MAGK;AACH,aAAKA,YAAL,GAAoB,EAApB;AACD;AACD,WAAKjB,OAAL,GAAe,EAAf;AACA,WAAKC,YAAL,GAAoB,EAApB;AACA,WAAKC,YAAL,GAAoB,EAApB;;AAEA,UAAIgB,aAAaV,IAAjB;AACA,UAAIW,SAAS,EAAb;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEAX,aAAO,KAAKY,eAAL,CAAqBZ,IAArB,CAAP;AACA,UAAI,KAAKR,OAAL,CAAaL,MAAb,GAAsB,CAA1B,EAA6B;AAC3BwB,eAAO,CAAP,IAAY,IAAZ;AACAA,eAAO,CAAP,IAAY,IAAZ;AACD,OAHD,MAIK;AACH;AACA,YAAIE,gBAAgB,KAAKrB,OAAL,CAAaL,MAAb,GAAsB,CAA1C;;AAEA;AACA;AACA;AACA;AACA,YAAI2B,QAAQ,IAAZ;AACA,aAAKA,KAAL,IAAczC,KAAK0C,UAAnB,EAA+B;AAC7B,iBAAOf,KAAKgB,QAAL,CAAcF,KAAd,CAAP;AACEd,mBAAOA,KAAKiB,OAAL,CAAaH,KAAb,EAAoBzC,KAAK0C,UAAL,CAAgBD,KAAhB,CAApB,CAAP;AADF;AAED;;AAED;AACA;AACA;AACA,YAAId,KAAKkB,OAAL,CAAa,GAAb,IAAoB,CAAC,CAAzB,EAA4B;AAC1B,gBAAO,IAAId,KAAJ,CAAU,mDAAV,CAAP;AACD,SAnBE,CAmBD;;AAEF;AACA;AACA;AACA;AACAO,iBAAS,KAAKQ,eAAL,CAAqBnB,IAArB,EAA2BU,UAA3B,CAAT;AACA,YAAIU,YAAYT,OAAO,CAAP,CAAhB;;AAEA;AACA;AACA;AACA;AACA,YAAIvC,UAAUiD,eAAV,CAA0BD,SAA1B,KAAwC,OAAOA,SAAP,KAAqB,QAAjE,EAA2E;AACzEA,sBAAY,IAAI7C,IAAJ,CAAS;AACnB,uBAAWmC,UADQ;AAEnB,0BAAcU,SAFK;AAGnB,qBAASV;AAHU,WAAT,CAAZ;AAKAC,iBAAO,CAAP,IAAYS,SAAZ;AACD,SAvCE,CAuCD;AACH,OAlFiC,CAkFhC;;AAEFT,aAAO,CAAP,IAAY,KAAKnB,OAAjB;AACA,UAAI,KAAKiB,YAAL,IAAqB,KAAKA,YAAL,CAAkBtB,MAAlB,GAA2B,CAApD,EACEwB,OAAO,CAAP,IAAY,KAAKF,YAAjB;AACF,aAAOE,MAAP;AAED,K,CAAC;;;AAGF;;;;;;;;;;;;;;;;;;;;;;;;;;;;;oCA0BgBX,I,EAAMU,U,EAAY;;AAEhC;AACA,UAAIU,YAAY,IAAhB;;AAEA;AACA,UAAIP,gBAAgB,KAAKrB,OAAL,CAAaL,MAAb,GAAsB,CAA1C;;AAEA;AACA;AACA;AACA,UAAImC,aAAa,KAAKC,cAAL,CAAoBvB,IAApB,EAA0BU,UAA1B,CAAjB;AACAG,sBAAgBS,WAAW,CAAX,CAAhB;;AAEA;AACA,UAAIE,SAAS,EAAb;;AAEA;AACA,UAAI,CAACX,aAAL,EAAoB;AAClBb,eAAOsB,WAAW,CAAX,CAAP;AACAZ,qBAAaY,WAAW,CAAX,CAAb;;AAEA;AACA;AACA,YAAIG,WAAW,KAAKC,eAAL,CAAqB1B,IAArB,EAA2BU,UAA3B,CAAf;;AAEAG,wBAAgBY,SAAS,CAAT,CAAhB;AACA,YAAI,CAACZ,aAAL,EAAoB;AAClBW,mBAASC,SAAS,CAAT,CAAT;AACAf,uBAAae,SAAS,CAAT,CAAb;AACA;AACA,cAAIE,OAAOH,OAAOrC,MAAlB;AACA,eAAK,IAAIyC,KAAK,CAAd,EAAiBA,KAAKD,IAAtB,EAA4BC,IAA5B,EAAkC;AAChC;AACA,gBAAIC,UAAUL,OAAOI,EAAP,EAAW,IAAX,CAAd;;AAEA;;AAEA;AACA;AACA,gBAAIxD,UAAUiD,eAAV,CAA0BQ,OAA1B,CAAJ,EAAwC;AACtCL,qBAAOI,EAAP,EAAW,IAAX,IAAmBE,OAAOD,OAAP,CAAnB;AACD,aAFD,MAIK;AACH;AACA;AACA;;AAEA,kBAAIA,QAAQX,OAAR,CAAgB,KAAKjC,WAArB,KAAqC,CAAzC,EAA4C;AAC1C,oBAAI8C,YAAY,KAAKC,cAAL,CAAoBH,OAApB,EAA6BnB,UAA7B,CAAhB;AACA;AACA;AACA,oBAAI,CAACG,aAAL,EACEA,gBAAgBkB,UAAU,CAAV,CAAhB;;AAEF;AACA;AACA;AACA,oBAAI,CAAClB,aAAL,EAAoB;AAClBW,yBAAOI,EAAP,EAAW,IAAX,IAAmBG,UAAU,CAAV,CAAnB;AACD;AACF,eAbD,CAaE;;AAEF;AACA;AAhBA,mBAiBK;AACH,sBAAIE,OAAO,KAAKC,SAAL,CAAeL,OAAf,EAAwBnB,UAAxB,CAAX;AACA;AACA,sBAAIuB,KAAK,CAAL,MAAY,IAAhB,EAAsB;AACpBpB,oCAAgB,IAAhB;AACD,mBAFD,MAGK;AACHW,2BAAOI,EAAP,EAAW,IAAX,IAAmBK,KAAK,CAAL,CAAnB;AACAvB,iCAAauB,KAAK,CAAL,CAAb;AACD;AACF,iBAhCE,CAgCD;AACH,aA7C+B,CA6C9B;AACH,WAnDiB,CAmDhB;AACH,SA7DiB,CA6DhB;AACH,OAhF+B,CAgF9B;;AAEF;AACA,UAAI,CAACpB,aAAL,EAAoB;AAClB;AACA,YAAI,CAACW,OAAO,CAAP,MAAc,IAAd,IAAsBA,OAAO,CAAP,MAAc,GAApC,IACAA,OAAO,CAAP,EAAU,IAAV,MAAoB3B,SADpB,IACiC2B,OAAO,CAAP,EAAU,IAAV,MAAoB,IADtD,KAEG,KAAKhC,OAAL,CAAaL,MAAb,KAAwB,CAF/B,EAEkC;AAChC;AACA,eAAKK,OAAL,CAAa2C,IAAb,CAAkB,kBAAgBzB,UAAhB,gJAAlB;AAGAG,0BAAgB,IAAhB;AACD;AACF;AACD,UAAI,CAACA,aAAL,EAAoB;AAClBO,oBAAY,KAAKgB,sBAAL,CAA4BZ,MAA5B,EAAoCd,UAApC,CAAZ;AACD;AACD,aAAO,CAACU,SAAD,EAAYV,UAAZ,CAAP;AACD,K,CAAC;;;AAGF;;;;;;;;;;;;;;;;oCAagB2B,O,EAAS;AACvB,UAAIC,YAAYD,QAAQnB,OAAR,CAAgB,GAAhB,CAAhB;AACA,aAAOoB,aAAa,CAApB,EAAuB;;AAErB,YAAIC,cAAaF,QAAQnB,OAAR,CAAgB,GAAhB,CAAjB;AACA,YAAIqB,cAAa,CAAjB,EAAoB;AAClB,eAAK/C,OAAL,CAAa2C,IAAb,CAAkB,sDAChB,KAAKrD,SADW,GACCuD,QAAQG,MAAR,CAAeF,SAAf,CADD,GAEhB,KAAKvD,UAFP;AAGAuD,sBAAY,CAAC,CAAb;AACD,SALD,MAMK;AACH,cAAIG,WAAWJ,QAAQK,SAAR,CAAkBJ,SAAlB,EAA6BC,cAAa,CAA1C,CAAf;AACA,cAAII,OAAO,KAAKjD,YAAL,CAAkBP,MAAlB,CAAyByD,QAAzB,EAAX;AACAP,oBAAUA,QAAQpB,OAAR,CAAgBwB,QAAhB,EAA0B,KAAKrD,UAAL,GAAkBuD,IAAlB,GAClC,KAAKvD,UADG,CAAV;AAEA,eAAKM,YAAL,CAAkByC,IAAlB,CAAuBM,QAAvB;AACAH,sBAAYD,QAAQnB,OAAR,CAAgB,GAAhB,CAAZ;AACD;AACF,OAnBsB,CAmBrB;;AAEF;AACA,UAAIqB,aAAaF,QAAQnB,OAAR,CAAgB,GAAhB,CAAjB;AACA,UAAIqB,cAAc,CAAlB,EACE,KAAK/C,OAAL,CAAa2C,IAAb,CAAkB,sDAChB,KAAKrD,SADW,GACCuD,QAAQK,SAAR,CAAkB,CAAlB,EAAqBH,aAAa,CAAlC,CADD,GAEhB,KAAKxD,UAFP;AAGF,aAAOsD,OAAP;AACD,K,CAAC;;;AAGF;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;mCA8BeA,O,EAAS3B,U,EAAY;;AAElC;AACA,UAAImC,YAAY,EAAhB;AACA,UAAIC,aAAa,CAAjB;AACA,UAAIC,iBAAiB,KAArB;;AAEA,UAAIC,KAAK,KAAKvD,YAAL,CAAkBN,MAA3B;;AAEA;AACA;AACA;AACA,UAAI8D,YAAY,CAAhB;;AAEA;AACA;AACA;AACA;AACA,aAAOZ,YAAY,EAAZ,IAAkB,CAACU,cAA1B,EAA0C;AACxC,YAAIG,SAAS,CAAb;AACA,YAAIC,UAAU,CAAd;AACA,YAAIC,UAAUf,QAAQnB,OAAR,CAAgB,GAAhB,CAAd;;AAEA;AACA;AACA;AACA,YAAIkC,UAAU,CAAd,EAAiB;AACf,cAAIC,WAAWhB,QAAQnB,OAAR,CAAgB,GAAhB,CAAf;AACA,cAAImC,YAAY,CAAhB,EAAmB;AACjB,gBAAIC,SAAS,6DACOjB,QAAQK,SAAR,CAAkB,CAAlB,EAAqBW,WAAWJ,SAAhC,CADP,UAER,KAAKnE,SAFG,GAESuD,QAAQG,MAAR,CAAea,QAAf,EAAyB,CAAzB,CAFT,GAEuC,KAAKtE,UAF5C,CAAb;AAGA,gBAAIsE,WAAWhB,QAAQlD,MAAR,GAAiB,CAAhC,EAAmC;AACjCmE,6BAAajB,QAAQG,MAAR,CAAea,WAAW,CAA1B,CAAb;AACD;AACD,iBAAK7D,OAAL,CAAa2C,IAAb,CAAkBmB,MAAlB;AACAT,sBAAUC,UAAV,IAAwBT,OAAxB;AACAU,6BAAiB,IAAjB;AACD,WAVD,CAUE;;AAEF;AACA;AACA;AAdA,eAeK;AACHF,wBAAUC,UAAV,IAAwBT,OAAxB;AACAA,wBAAU,EAAV;AACD,aApBc,CAoBb;AACH,SArBD,CAqBE;;AAEF;AACA;AAxBA,aAyBK;AACHa,sBAAU,CAAV;AACA;AACA,gBAAIvB,OAAOU,QAAQlD,MAAnB;AACA,gBAAIiE,UAAU,CAAd,EAAiB;AACfP,wBAAUC,YAAV,IAA0BT,QAAQG,MAAR,CAAe,CAAf,EAAkBY,OAAlB,CAA1B;AACD;;AAED;AACA;AACA;AACA;AACA;AACA;AACA;AACA,gBAAIC,YAAW,CAAf;AACA,gBAAIE,IAAIH,UAAU,CAAlB;AACA,mBAAOG,IAAI5B,IAAJ,IAAYuB,UAAUC,OAA7B,EAAsCI,GAAtC,EAA2C;AACzC,kBAAIlB,QAAQkB,CAAR,MAAe,GAAnB,EACEL,UAAU,CAAV,CADF,KAEK,IAAIb,QAAQkB,CAAR,MAAe,GAAnB,EACHJ,WAAW,CAAX;AACH;;AAED;AACA;AACA;AACA;AACA;AACA;AACA,gBAAID,WAAWC,OAAf,EAAwB;AACtBE,0BAAWE,CAAX;AACAV,wBAAUC,YAAV,IAA0B,KAAK7D,WAAL,GAAmB+D,GAAGJ,QAAH,EAAnB,GAAmC,KAAK3D,WAAlE;AACA,kBAAIuE,YAAY,KAAKrC,eAAL,CACdkB,QAAQK,SAAR,CAAkBU,UAAU,CAA5B,EAA+BC,YAAW,CAA1C,CADc,EACgC3C,UADhC,CAAhB;AAEA,kBAAI8C,UAAU,CAAV,MAAiB,IAArB,EACET,iBAAiB,IAAjB,CADF,KAEK;AACHrC,6BAAa8C,UAAU,CAAV,CAAb;AACA,qBAAK/D,YAAL,CAAkBuD,IAAlB,IAA0BQ,UAAU,CAAV,CAA1B;AACAnB,0BAAUA,QAAQG,MAAR,CAAea,SAAf,CAAV;AACAJ,4BAAYI,SAAZ;AACD;AACF,aAbD,CAaE;;AAEF;AACA;AAhBA,iBAiBK;AACHR,0BAAUV,IAAV,CAAezB,WAAW8B,MAAX,CAAkBY,OAAlB,CAAf;AACA,qBAAK5D,OAAL,CAAa2C,IAAb,CAAkB,6DACbzB,WAAWgC,SAAX,CAAqB,CAArB,EAAwBU,UAAUH,SAAlC,CADa,UAEb,KAAKnE,SAFQ,GAEI4B,WAAW8B,MAAX,CAAkBY,OAAlB,EAA2B,CAA3B,CAFJ,UAGb,KAAKrE,UAHQ,GAGK2B,WAAW8B,MAAX,CAAkBY,UAAU,CAA5B,CAHL,CAAlB;AAIAL,iCAAiB,IAAjB;AACD;AACF,WAxFuC,CAwFtC;AACH,OA3GiC,CA2GhC;AACF,UAAIA,cAAJ,EACE,KAAKtD,YAAL,GAAoB,EAApB;AACF,aAAO,CAACoD,UAAUY,IAAV,CAAe,EAAf,CAAD,EAAqB/C,UAArB,EAAiCqC,cAAjC,CAAP;AACD,K,CAAC;;;AAGF;;;;;;;;;;;;;;;;;;;;;;oCAmBgB/C,I,EAAMU,U,EAAY;;AAEhC;AACA;AACA;;AAEA,UAAIgD,UAAU1D,KAAK2D,KAAL,CAAW,gBAAX,CAAd;AACA,UAAI9C,gBAAgB,KAApB;AACA,UAAIW,SAAS,EAAb;AACA,UAAIoC,gBAAgB,0CAApB;;AAEA;AACA;AACA;AACA,UAAIF,QAAQ,CAAR,MAAe,GAAnB,EAAwB;AACtBA,gBAAQG,OAAR,CAAgB,GAAhB;AACD;AACD;AACA;AAJA,WAKK,IAAIH,QAAQ,CAAR,MAAe,GAAnB,EAAwB;AAC3B,eAAKlE,OAAL,CAAa2C,IAAb,CAAqBzB,UAAH,yLAAlB;AAIAG,0BAAgB,IAAhB;AACD;AACD,UAAI,CAACA,aAAL,EAAoB;AAClB;AACA;AACA;AACA;;AAEA,YAAI,CAACzC,UAAUiD,eAAV,CAA0BqC,QAAQ,CAAR,CAA1B,CAAL,EAA4C;AAC1C,cAAII,SAASJ,QAAQ,CAAR,EAAWC,KAAX,CAAiBC,aAAjB,CAAb;AACA,cAAIE,UAAUA,OAAO3E,MAAP,KAAkB,CAA5B,IAAiC2E,OAAO,CAAP,MAAc,EAA/C,IACFA,OAAO,CAAP,MAAc,EADZ,IACkBA,OAAO,CAAP,EAAU5C,OAAV,CAAkB,KAAK9B,UAAvB,MAAuC,CAD7D,EACgE;AAC9D,gBAAI2E,UAAUD,OAAO,CAAP,CAAd;;AAEA,gBAAI,CAACjD,aAAD,IAAkBiD,OAAO,CAAP,EAAU9C,QAAV,CAAmB,KAAK/B,WAAxB,CAAtB,EAA4D;AAC1D,kBAAI+E,aAAa,KAAKhC,cAAL,CAAoB8B,OAAO,CAAP,CAApB,EAA+BpD,UAA/B,CAAjB;AACAoD,qBAAO,CAAP,IAAYE,WAAW,CAAX,EAAc,SAAd,CAAZ;AACAD,8BAAcD,OAAO,CAAP,CAAd;AACAjD,8BAAgBmD,WAAW,CAAX,CAAhB;AACD;AACD,gBAAI,CAACnD,aAAL,EAAoB;AAClB,mBAAKrB,OAAL,CAAa2C,IAAb,CAAkB,KAAG2B,OAAO,CAAP,CAAH,GAAeC,OAAf,0CACX,KAAKzE,WADM,GACQwE,OAAO,CAAP,CADR,SACqBC,OADrB,GAC+B,KAAKxE,SADpC,CAAlB;AAEAmB,2BAAaA,WAAWO,OAAX,MAAsB6C,OAAO,CAAP,CAAtB,GAAkCC,OAAlC,EACRD,OAAO,CAAP,CADQ,SACKC,OADL,CAAb;AAEAL,sBAAQ,CAAR,IAAaI,OAAO,CAAP,CAAb;AACAJ,sBAAQG,OAAR,CAAgBC,OAAO,CAAP,CAAhB,EAA2B,GAA3B;AACD;AACF;AACF,SA3BiB,CA2BhB;;AAEF;AACA;AACA;AACA;AACA;AACA;AACA;AACA,YAAI,CAACjD,aAAL,EAAoB;AAClB,cAAIe,KAAK8B,QAAQvE,MAAjB;AACAqC,mBAAS,CAAC,EAACyC,IAAI,EAAL,EAASC,IAAIR,QAAQ,CAAR,CAAb,EAAD,CAAT;AACA,eAAK,IAAIS,IAAI,CAAb,EAAgBA,IAAIvC,EAApB,EAAwBuC,GAAxB,EAA6B;;AAE3B;AACA;AACA,gBAAIC,QAAQV,QAAQS,GAAR,CAAZ;AACA;AACA;AACA,gBAAI,CAACT,QAAQS,CAAR,CAAL,EAAiB;AACf,mBAAK3E,OAAL,CAAa2C,IAAb,CAAqBzB,UAAH,4EACsB,KAAK5B,SAD3B,UAEbsF,KAFa,GAEL,KAAKrF,UAFA,OAAlB;AAGAoF,kBAAIvC,EAAJ;AACAf,8BAAgB,IAAhB;AACD,aAND,MAOK,IAAIxC,KAAKgG,SAAL,CAAerD,QAAf,CAAwB0C,QAAQS,CAAR,CAAxB,CAAJ,EAAyC;AAC5C,mBAAK3E,OAAL,CAAa2C,IAAb,CAAqBzB,UAAH,uEACiB,KAAK5B,SADtB,UAEbsF,KAFa,GAEL,KAAKrF,UAFA,WAEgB,KAAKD,SAFrB,UAGb4E,QAAQS,CAAR,CAHa,GAGA,KAAKpF,UAHL,UAGoB,KAAKD,SAHzB,UAIbsF,KAJa,GAILV,QAAQS,CAAR,CAJK,GAIQ,KAAKpF,UAJb,OAAlB;AAKAoF,kBAAIvC,EAAJ;AACAf,8BAAgB,IAAhB;AACD,aARI,MASA;AACH;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,kBAAI,CAACzC,UAAUiD,eAAV,CAA0BqC,QAAQS,CAAR,CAA1B,CAAL,EAA4C;AAC1C,oBAAIG,UAAUZ,QAAQS,CAAR,EAAWR,KAAX,CAAiBC,aAAjB,CAAd;AACA,oBAAIU,WAAWA,QAAQnF,MAAR,KAAmB,CAA9B,IAAmCmF,QAAQ,CAAR,MAAe,EAAlD,IACFA,QAAQ,CAAR,MAAe,EADb,IACmBA,QAAQ,CAAR,EAAWpD,OAAX,CAAmB,KAAK9B,UAAxB,MAAwC,CAD/D,EACkE;AAChE,sBAAImF,gBAAgBD,QAAQ,CAAR,CAApB;AACA,sBAAI,CAACzD,aAAD,IAAkByD,QAAQ,CAAR,EAAWtD,QAAX,CAAoB,KAAK/B,WAAzB,CAAtB,EAA6D;AAC3D,wBAAI+E,cAAa,KAAKhC,cAAL,CAAoBsC,QAAQ,CAAR,CAApB,EAAgC5D,UAAhC,CAAjB;AACA4D,4BAAQ,CAAR,IAAaN,YAAW,CAAX,EAAc,SAAd,CAAb;AACAO,0CAAoBD,QAAQ,CAAR,CAApB;AACAzD,oCAAgBmD,YAAW,CAAX,CAAhB;AACA,wBAAI,CAACnD,aAAL,EAAoB;AAClB,2BAAKrB,OAAL,CAAa2C,IAAb,CAAkB,KAAGmC,QAAQ,CAAR,CAAH,GAAgBC,aAAhB,0CACK,KAAKjF,WADV,GACwBgF,QAAQ,CAAR,CADxB,SACsCC,aADtC,UAEb,KAAKhF,SAFQ,CAAlB;AAGA,0BAAIiF,qBAAmBF,QAAQ,CAAR,CAAnB,SAAiCC,aAAjC,MAAJ;AACA7D,mCAAaA,WAAWO,OAAX,MAAsBqD,QAAQ,CAAR,CAAtB,GAAmCC,aAAnC,EACXC,YADW,CAAb;AAEA,0BAAIC,aAAa,KAAKlD,cAAL,CAAoBiD,YAApB,EAAkC9D,UAAlC,CAAjB;AACAG,sCAAgB4D,WAAW,CAAX,CAAhB;AACA,0BAAI,CAAC5D,aAAL,EAAoB;AAClBW,+BAAOW,IAAP,CAAY,EAAC8B,IAAIG,KAAL,EAAYF,IAAIO,WAAW,CAAX,CAAhB,EAAZ;AACD;AACD;AACD;AACF,mBAnBD,CAmBE;AAnBF,uBAoBK;AACH,0BAAIC,YAAY,MAAMJ,QAAQ,CAAR,CAAN,GAAmB,GAAnB,GAAyBA,QAAQ,CAAR,CAAzB,GAAsC,GAAtD;AACA,0BAAIhD,aAAa,KAAKC,cAAL,CAAoBmD,SAApB,EAA+BhE,UAA/B,CAAjB;AACA;AACA;AACA,0BAAIY,WAAW,CAAX,CAAJ,EAAmB;AACjB6C,4BAAIvC,EAAJ;AACAf,wCAAgB,IAAhB;AACD,uBAHD,MAIK;AACH,6BAAKrB,OAAL,CAAa2C,IAAb,CAAqBmC,QAAQ,CAAR,CAAH,0CACK,KAAKhF,WADV,GACwBgF,QAAQ,CAAR,CADxB,SACsCA,QAAQ,CAAR,CADtC,UAEb,KAAK/E,SAFQ,CAAlB;AAGAmB,qCAAaA,WAAWO,OAAX,CAAmBqD,QAAQ,CAAR,CAAnB,EAA+BI,SAA/B,CAAb;AACAlD,+BAAOW,IAAP,CAAY,EAAC8B,IAAIG,KAAL,EAAYF,IAAI5C,WAAW,CAAX,CAAhB,EAAZ;AACD,uBAfE,CAeD;AACH,qBAtC+D,CAsC9D;AACH,iBAxCD,CAwCE;AAxCF,qBAyCK;AACHE,2BAAOW,IAAP,CAAY,EAAC8B,IAAIG,KAAL,EAAYF,IAAIR,QAAQS,CAAR,CAAhB,EAAZ;AACD;AACF,eA9CD,MA+CK;AACH3C,uBAAOW,IAAP,CAAY,EAAC8B,IAAIG,KAAL,EAAYF,IAAIR,QAAQS,CAAR,CAAhB,EAAZ;AACD;AACF,aAlF0B,CAkFzB;AACH,WAtFiB,CAsFhB;AACH,SA3HiB,CA2HhB;AACH,OAtJ+B,CAsJ9B;AACF,aAAO,CAAC3C,MAAD,EAASd,UAAT,EAAqBG,aAArB,CAAP;AACD,K,CAAC;;;AAGF;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;mCA4Be8D,I,EAAMjE,U,EAAY;AAC/B,UAAIG,gBAAgB,KAApB;AACA,UAAI+D,SAAS,EAAb;AACA,UAAIC,UAAU,IAAd;AACA,UAAIC,cAAc,IAAlB;AACA,UAAIC,cAAc,IAAlB;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA,UAAIC,QAAQL,KAAKzD,OAAL,CAAa,KAAKjC,WAAlB,CAAZ;AACA,UAAIgG,UAAU,IAAd;AACA,UAAID,QAAQ,CAAZ,EAAe;AACbC,kBAAUN,KAAKnC,MAAL,CAAY,CAAZ,EAAewC,QAAQ,CAAvB,CAAV;AACD;AACD,UAAIE,QAAQP,KAAKQ,WAAL,CAAiB,KAAKlG,WAAtB,CAAZ;AACA,UAAImG,UAAU,IAAd;AACA,UAAIF,QAAQ,KAAKhG,SAAb,GAAyByF,KAAKxF,MAAlC,EAA0C;AACxCiG,kBAAUT,KAAKnC,MAAL,CAAY0C,QAAQ,KAAKhG,SAAzB,CAAV;AACD;;AAED;AACA,UAAImG,WAAWV,KAAKjC,SAAL,CAAesC,QAAQ,KAAK9F,SAA5B,EAAuCgG,KAAvC,CAAf;;AAEA;AACA;AACA,UAAI9G,UAAUiD,eAAV,CAA0BgE,QAA1B,CAAJ,EAAyC;AACvCR,kBAAU,KAAKpF,YAAL,CAAkBqC,OAAOuD,QAAP,CAAlB,CAAV;AACA,YAAI,CAACjH,UAAUiD,eAAV,CAA0BwD,OAA1B,CAAL,EAAyC;AACvCF,iBAAOE,QAAQS,OAAf;AACD,SAFD,MAGK;AACHX,iBAAOE,OAAP;AACD;AACF;AACD;AATA,WAUK;AACH,gBAAO,IAAIzE,KAAJ,CAAU,8CAA4CiF,QAA5C,wBACHV,IADG,OAAV,CAAP;AAED;;AAED;AACA;AACA,UAAIM,OAAJ,EAAa;AACX;AACA,YAAI7G,UAAUiD,eAAV,CAA0B4D,OAA1B,CAAJ,EAAwC;AACtC,cAAIM,OAAOV,QAAQW,WAAR,CAAoB,YAApB,CAAX;AACAD,kBAAQzD,OAAOmD,OAAP,CAAR;AACAJ,kBAAQY,UAAR,CAAmB,EAAC,cAAcF,IAAf,EAAnB;AACAZ,iBAAUM,OAAV,SAAqBN,IAArB;AACA,eAAKnF,OAAL,CAAa2C,IAAb,CAAkB,KAAG8C,OAAH,GAAaN,IAAb,oCAChB,KAAKrF,WADW,GACGqF,IADH,GACU,KAAKpF,SADjC;AAED,SAPD,MAQK;AACH,cAAI0F,QAAQ/D,OAAR,CAAgB,KAAK9B,UAArB,KAAoC,CAAxC,EAA2C;AACzC,gBAAIsG,UAAU,KAAKC,YAAL,CAAkBV,OAAlB,EAA2BvE,UAA3B,CAAd;AACA;AACA;AACA;AACA;AACA,gBAAIgF,QAAQ,CAAR,KAAcA,QAAQ,CAAR,CAAlB,EAA8B;AAC5B,oBAAO,IAAItF,KAAJ,CAAU,yCACZ6E,OADY,qFAEWJ,QAAQS,OAFnB,CAAV,CAAP;AAGD;AACD;AACA;AACAX,oBAAQe,QAAQ,CAAR,CAAR;AACA,iBAAKlG,OAAL,CAAa2C,IAAb,CAAkB,oBAAkBuD,QAAQ,CAAR,CAAlB,gDACO,KAAKpG,WADZ,GAC0BqF,IAD1B,GACiC,KAAKpF,SADxD;AAED;AACD;AACA;AACA;AAnBA,eAoBK,IAAI,CAAC,KAAKkB,YAAV,EAAwB;AAC3B,mBAAKjB,OAAL,CAAa2C,IAAb,CAAqB8C,OAAH,iCAAsCN,IAAtC,sDAAlB;AAEA9D,8BAAgB,IAAhB;AACD;AACD;AALK,iBAMA;AACH,oBAAI+E,cAAc,KAAKC,eAAL,CAAqBZ,OAArB,CAAlB;AACApE,gCAAkB+E,gBAAgB,WAAlC;AAED,eA/BE,CA+BD;AACA;AACH,SA3CU,CA2CT;AACH,OA1F8B,CA0F7B;;AAEF;AACA,UAAIR,OAAJ,EAAa;AACX;AACA,YAAIA,QAAQlE,OAAR,CAAgB,KAAK9B,UAArB,KAAoC,CAAxC,EAA2C;AACzC,cAAIsG,WAAU,KAAKC,YAAL,CAAkBP,OAAlB,EAA2B1E,UAA3B,CAAd;AACA;AACA;AACA;AACA;AACA,cAAIgF,SAAQ,CAAR,KAAcA,SAAQ,CAAR,CAAlB,EAA8B;AAC5B,kBAAO,IAAItF,KAAJ,CAAU,wCACZgF,OADY,qFAEWP,QAAQS,OAFnB,CAAV,CAAP;AAGD;AACD;AACA;AACAX,kBAAQe,SAAQ,CAAR,CAAR;AACD;AACD;AACA;AAhBA,aAiBK;;AAEH,gBAAItH,UAAUiD,eAAV,CAA0B+D,OAA1B,CAAJ,EAAwC;AACtCT,sBAAQS,OAAR;AACAP,wBAAUA,QAAQiB,KAAR,CAAchE,OAAOsD,OAAP,CAAd,CAAV;AACA,mBAAK5F,OAAL,CAAa2C,IAAb,CAAkB,kBAAgBiD,OAAhB,mGAEhB,KAAK9F,WAFW,GAEGqF,IAFH,GAEU,KAAKpF,SAFjC;AAGD;AACD;AACA;AACA;AATA,iBAUK,IAAI,CAAC,KAAKkB,YAAV,EAAwB;AAC3B,qBAAKjB,OAAL,CAAa2C,IAAb,CAAkB,UAAQiD,OAAR,iCAA2CT,IAA3C,sDAAlB;AAEA9D,gCAAgB,IAAhB;AACD;AACD;AALK,mBAMA;AACH,sBAAI+E,eAAc,KAAKC,eAAL,CAAqBZ,OAArB,CAAlB;AACApE,kCAAkB+E,iBAAgB,WAAlC;AACD,iBArBE,CAqBD;AACH,WAzCU,CAyCT;AACH,OAvI8B,CAuI7B;AACF,UAAI,CAAC/E,aAAL,EAAoB;AAClB,YAAI,CAACgE,OAAL,EAAc;AACZA,oBAAU,IAAItG,IAAJ,CAAS;AACjB,uBAAWoG,IADM;AAEjB,0BAAc,CAFG;AAGjB,qBAASA,IAHQ,EAAT,CAAV;AAID,SALD,MAMK,IAAIvG,UAAUiD,eAAV,CAA0BwD,OAA1B,CAAJ,EAAwC;AAC3CA,oBAAU,IAAItG,IAAJ,CAAS,EAAC,WAAWsG,OAAZ;AACnB,0BAAcA,OADK;AAEnB,qBAASA,OAFU,EAAT,CAAV;AAGD,SAJI,MAKA;AACHA,kBAAQS,OAAR,GAAkBX,IAAlB;AACD;AACF;AACD,aAAO,CAACE,OAAD,EAAUhE,aAAV,CAAP;AACD,K,CAAC;;AAEF;;;;;;;;;;;;;;;;;;;;;;;;;iCAsBa8D,I,EAAMjE,U,EAAY;;AAE7B;AACA;AACA,UAAIqF,QAAQpB,KAAKzD,OAAL,CAAa,KAAK9B,UAAlB,CAAZ;AACA,UAAI4G,YAAaD,QAAQ,CAAT,GAAcpB,KAAKjC,SAAL,CAAe,CAAf,EAAkBqD,KAAlB,CAAd,GAAyC,IAAzD;AACA,UAAIA,UAAU,CAAd,EAAiB;AACfpB,eAAOA,KAAKnC,MAAL,CAAYuD,KAAZ,CAAP;AACD;;AAED;AACA,UAAIE,QAAQtB,KAAKzD,OAAL,CAAa,KAAK9B,UAAlB,EAA8B,CAA9B,CAAZ;AACA,UAAI8G,UAAYD,QAAQ,KAAK5G,SAAd,GAA2BsF,KAAKxF,MAAjC,GACZwF,KAAKnC,MAAL,CAAYyD,QAAQ,KAAK5G,SAAzB,CADY,GAC0B,IADxC;;AAGA;AACA;AACA,UAAI8G,MAAMxB,KAAKjC,SAAL,CAAe,KAAKrD,SAApB,EAA+B4G,KAA/B,CAAV;AACA,UAAIG,SAAStE,OAAOqE,GAAP,CAAb;AACA,UAAI,CAAC/H,UAAUiD,eAAV,CAA0B8E,GAA1B,CAAD,IAAmCC,UAAU,KAAK1G,YAAL,CAAkBP,MAAnE,EAA2E;AACzE,cAAO,IAAIiB,KAAJ,CAAU,iDAA+C+F,GAA/C,wBACTxB,IADS,+BACqBjE,UADrB,CAAV,CAAP;AAED;;AAED;AACAiE,aAAO,KAAKjF,YAAL,CAAkB0G,MAAlB,CAAP;AACA,aAAO,CAACzB,IAAD,EAAOqB,SAAP,EAAkBE,OAAlB,CAAP;AACD,K,CAAC;;;AAGF;;;;;;;;;;;;;;;;;;;;;;;;;;;;oCAyBgBvB,I,EAAM;;AAEpB,UAAIhE,SAASvC,UAAUiI,WAAV,CAAsB1B,IAAtB,CAAb;AACA,UAAIhE,OAAO,QAAP,MAAqB,WAAzB,EAAsC;AACpC,YAAI2F,UAAU,EAAd;AACAA,gBAAQ,KAAR,IAAoB3B,IAAH,2FAAjB;AAEA2B,gBAAQ,aAAR,IAAyB3B,IAAzB;AACA,YAAI4B,SAAS5F,OAAO,OAAP,EAAgBxB,MAA7B;AACAmH,gBAAQ,OAAR,IAAmB,EAAnB;AACA,aAAK,IAAIE,IAAI,CAAb,EAAgBA,IAAID,MAApB,EAA4BC,GAA5B,EAAiC;AAC/B,cAAIC,OAAO9F,OAAO,OAAP,EAAgB6F,CAAhB,CAAX;AACA,cAAIE,YAAY,CAACD,KAAK,MAAL,CAAD,EAAeA,KAAK,MAAL,CAAf,EAA6BA,KAAK,UAAL,CAA7B,CAAhB;;AAEAH,kBAAQ,OAAR,EAAiBnE,IAAjB,CAAsBuE,SAAtB;AACD;AACD,aAAKjG,YAAL,CAAkB0B,IAAlB,CAAuBmE,OAAvB;AACD,OAdD,MAeK;AACH,aAAK9G,OAAL,CAAa2C,IAAb,CAAqBwC,IAAH,iEAAlB;AAED;AACD,aAAOhE,OAAO,QAAP,CAAP;AACD,K,CAAC;;;AAGF;;;;;;;;;;;;;;;;;;;;;;;;8BAqBUgG,K,EAAOjG,U,EAAY;;AAE3B;AACA;AACA,UAAImE,UAAU,KAAKlG,MAAL,CAAYiI,aAAZ,CAA0BD,KAA1B,CAAd;AACA,UAAI9B,OAAJ,EAAa;AACXA,kBAAUA,QAAQgC,KAAR,EAAV;AACD;;AAED;AACA;AALA,WAMK,IAAIF,MAAMzF,OAAN,CAAc,KAAK9B,UAAnB,KAAkC,CAAtC,EAAyC;AAC5C,cAAI0H,aAAa,KAAKC,sBAAL,CAA4BJ,KAA5B,EAAmCjG,UAAnC,CAAjB;AACAmE,oBAAUiC,WAAW,CAAX,CAAV;AACA,cAAIjC,OAAJ,EAAa;AACXnE,yBAAaoG,WAAW,CAAX,CAAb;AACD;AACD;AACA;AACA;AACA;AACD,SAVI,CAUH;;AAVG,aAYA;;AAEH;AACA;AACA;;AAEA,gBAAIH,MAAMzF,OAAN,CAAc,GAAd,IAAqB,CAAC,CAA1B,EAA6B;AAC3B,kBAAI8F,UAAUL,MAAM1F,OAAN,CAAc,GAAd,EAAmB,GAAnB,CAAd;AACA4D,wBAAU,KAAKlG,MAAL,CAAYiI,aAAZ,CAA0BI,OAA1B,CAAV;AACA,kBAAInC,OAAJ,EAAa;AACXA,0BAAUA,QAAQgC,KAAR,EAAV;AACAhC,wBAAQS,OAAR,GAAkBT,QAAQS,OAAR,CAAgBrE,OAAhB,CAAwB,GAAxB,EAA6B,GAA7B,CAAlB;AACA4D,wBAAQoC,OAAR,GAAkBpC,QAAQoC,OAAR,CAAgBhG,OAAhB,CAAwB,GAAxB,EAA6B,GAA7B,CAAlB;AACD;AACF;AACD;AACA;AACA,gBAAI,CAAC4D,OAAL,EAAc;AACZ,kBAAIqC,cAAc,MAAMP,KAAN,GAAc,GAAhC;AACA9B,wBAAU,KAAKlG,MAAL,CAAYiI,aAAZ,CAA0BM,WAA1B,CAAV;AACA,kBAAIrC,OAAJ,EAAa;AACXA,0BAAUA,QAAQgC,KAAR,EAAV;AACAnG,6BAAaA,WAAWO,OAAX,CAAmB0F,KAAnB,EAA0BO,WAA1B,CAAb;AACA,qBAAK1H,OAAL,CAAa2C,IAAb,CAAqBwE,KAAH,8CACbO,WADa,eACS,KAAK5H,WADd,IAEb4H,WAFa,UAEGrC,QAAQsC,KAFX,SAEoB,KAAK5H,SAFzB,CAAlB;AAGD,eATW,CASV;AACH,aA3BE,CA2BD;;AAEF;AACA,gBAAI,CAACsF,OAAL,EAAc;AACZ,kBAAIuC,aAAa,KAAKzI,MAAL,CAAY0I,aAAZ,CAA0BV,KAA1B,CAAjB;AACA,kBAAIS,cAAcA,WAAWjI,MAAX,GAAoB,CAAtC,EAAyC;AACvC0F,0BAAUuC,WAAW,CAAX,EAAcP,KAAd,EAAV;AACA,oBAAIS,UAAU,uBAAuBX,KAAvB,GAA+B,MAA/B,GACZ9B,QAAQS,OADI,GACM,KADN,GACc,KAAKhG,WADnB,GAEZuF,QAAQS,OAFI,GAEM,KAAK/F,SAFzB;AAGA,oBAAIgI,SAAS,KAAb;AACA,qBAAK,IAAIC,IAAI,CAAb,EAAgBA,IAAI,KAAKhI,OAAL,CAAaL,MAAjB,IAA2B,CAACoI,MAA5C,EAAoDC,GAApD;AACED,2BAAS,KAAK/H,OAAL,CAAagI,CAAb,MAAoBF,OAA7B;AADF,iBAEA,IAAI,CAACC,MAAL,EACE,KAAK/H,OAAL,CAAa2C,IAAb,CAAkBmF,OAAlB;AACF,oBAAIG,OAAO,IAAIC,MAAJ,CAAW,iBAAiBf,KAAjB,GAAyB,cAApC,CAAX;AACA,oBAAIgB,MAAMjH,WAAWiD,KAAX,CAAiB8D,IAAjB,CAAV;AACA/G,6BAAaA,WAAWO,OAAX,CAAmBwG,IAAnB,EAAyBE,IAAI,CAAJ,IAAS9C,QAAQS,OAAjB,GAA2BqC,IAAI,CAAJ,CAApD,CAAb;AACAhB,wBAAQ9B,QAAQS,OAAhB;AACD;AACF;;AAED;AACA;AACA,gBAAI,CAACT,OAAL,EAAc;;AAEZ;AACA;AACA;AACA,kBAAI/D,QAAQ,IAAZ;AACA,mBAAKA,KAAL,IAAczC,KAAK0C,UAAnB,EAA+B;AAC7B,oBAAI4F,MAAM3F,QAAN,CAAe3C,KAAK0C,UAAL,CAAgBD,KAAhB,CAAf,CAAJ,EACE6F,QAAQA,MAAM1F,OAAN,CAAc5C,KAAK0C,UAAL,CAAgBD,KAAhB,CAAd,EAAsCA,KAAtC,CAAR;AACH;AACD+D,wBAAU,KAAKlG,MAAL,CAAYiI,aAAZ,CAA0BD,KAA1B,CAAV;AACA,kBAAI9B,OAAJ,EACEA,UAAUA,QAAQgC,KAAR,EAAV;AACH;AACD,gBAAI,CAAChC,OAAL,EAAc;;AAEZ,kBAAI+C,WAAWjB,KAAf;AACA,kBAAIkB,WAAW,IAAf;AACA,kBAAIC,MAAM,IAAV;AACA,kBAAIC,UAAU,IAAd;AACA,kBAAIC,SAAS,IAAb;AACA,kBAAIC,SAAS,IAAb;AACA,kBAAIC,SAAS,IAAb;;AAEA;AACA;AACA,kBAAIC,aAAa,KAAKC,mBAAL,CAAyBzB,KAAzB,CAAjB;AACA,kBAAIwB,UAAJ,EAAgB;AACdxB,wBAAQwB,WAAW,CAAX,CAAR;AACAL,sBAAMK,WAAW,CAAX,CAAN;AACAN,2BAAW,KAAKlJ,MAAL,CAAYiI,aAAZ,CAA0BD,KAA1B,CAAX;AACD;;AAGD;AACA;AACA,kBAAI,CAACkB,QAAL,EAAe;AACb;AACAE,0BAAUpB,MAAM0B,MAAN,CAAa,CAAb,CAAV;AACAL,yBAAS,KAAKnJ,QAAL,CAAcyJ,eAAd,CAA8BP,OAA9B,CAAT;;AAEA;AACA,oBAAIC,MAAJ,EAAY;AACVC,2BAASD,OAAOO,QAAP,EAAT;AACAL,2BAASF,OAAOQ,MAAP,EAAT;AACA,sBAAIC,WAAWV,QAAQ5I,MAAvB;AACAwH,0BAAQA,MAAMnE,MAAN,CAAaiG,QAAb,CAAR;;AAEA;AACAZ,6BAAW,KAAKlJ,MAAL,CAAYiI,aAAZ,CAA0BD,KAA1B,CAAX;;AAEA;AACA;AACA;AACA;;AAEA,sBAAI,CAACkB,QAAD,IAAaE,WAAW,GAAxB,IAA+BpB,MAAMnE,MAAN,CAAa,CAAb,EAAgB,CAAhB,KAAsB,GAAzD,EAA8D;AAC5DuF,8BAAU,IAAV;AACAC,6BAAS,KAAKnJ,QAAL,CAAcyJ,eAAd,CAA8BP,OAA9B,CAAT;AACAE,6BAASD,OAAOO,QAAP,EAAT;AACA5B,4BAAQA,MAAMnE,MAAN,CAAa,CAAb,CAAR;;AAEA;AACAqF,+BAAW,KAAKlJ,MAAL,CAAYiI,aAAZ,CAA0BD,KAA1B,CAAX;AACD;AACF,iBA7BY,CA6BX;AACH,eApDW,CAoDV;;AAEF;AACA;AACA;AACA;AACA,kBAAI,CAACkB,QAAL,EAAe;AACbhD,0BAAU,IAAV;AACA;AACA,oBAAI,KAAKpE,YAAT,EAAuB;AACrB,sBAAImF,cAAc,KAAKC,eAAL,CAAqB+B,QAArB,CAAlB;AACD,iBAFD,MAGK;AACH,uBAAKpI,OAAL,CAAa2C,IAAb,CAAqByF,QAArB;AACD;AACF,eATD,MAUK;AACH;AACA;AACA/C,0BAAUgD,SAAShB,KAAT,EAAV;AACAhC,wBAAQ6D,SAAR,GAAoB,EAApB;AACA,oBAAIC,SAAS9D,QAAQW,WAAR,CAAoB,MAApB,CAAb;AACA,oBAAIoD,SAAS/D,QAAQW,WAAR,CAAoB,YAApB,CAAb;AACA,oBAAIqD,UAAUhE,QAAQW,WAAR,CAAoB,OAApB,CAAd;AACA,oBAAIsD,YAAYjE,QAAQW,WAAR,CAAoB,SAApB,CAAhB;AACA,oBAAIuD,iBAAiBlE,QAAQW,WAAR,CAAoB,cAApB,CAArB;AACA;AACA;AACA,oBAAIsC,GAAJ,EAAS;AACPA,wBAAMkB,SAASlB,GAAT,CAAN;AACA,sBAAImB,SAASnB,GAAb;AACA,sBAAIa,MAAJ,EACEA,SAASA,OAAOO,GAAP,CAAWpB,GAAX,CAAT;AACFc,2BAASO,KAAKC,GAAL,CAASR,MAAT,EAAiBd,GAAjB,CAAT;AACAjD,0BAAQY,UAAR,CAAmB,EAAC,cAAcmD,MAAf,EAAnB;;AAEA;AACA,sBAAIZ,MAAJ,EAAY;;AAEV;AACA;AACA;AACA;AACA,wBAAIE,MAAJ,EAAY;AACVe,gCAAUjB,OAAOQ,MAAP,EAAV;AACAP,+BAASkB,KAAKC,GAAL,CAAS,EAAT,EAAaH,MAAb,CAAT;AACD;AACD;AACA;AACA;AACA;AACA;AACA;AACD,mBAzBM,CAyBL;AACH,iBAtCE,CAsCD;;AAEF;AACA;AACA,oBAAIjB,MAAJ,EAAY;AACV,sBAAInD,QAAQwE,IAAZ,EAAkB;AAChBxE,4BAAQY,UAAR,CAAmB,EAAC,WAAWwC,MAAZ,EAAnB;AACD,mBAFD,MAGK;AACHW,8BAAUX,MAAV;AACApD,4BAAQY,UAAR,CAAmB,EAAC,cAAcmD,MAAf,EAAnB;AACD;AACF;AACD;AACA;AACA,oBAAIU,UAAUzE,QAAQS,OAAtB;AACA,oBAAI0C,MAAJ,EAAY;AACVa,4BAAUb,OAAOuB,OAAP,KAAmBV,OAA7B;AACAS,4BAAUvB,UAAUuB,OAApB;AACAR,8BAAYd,OAAOwB,SAAP,KAAqBV,SAAjC;AACAC,mCAAiBf,OAAOyB,cAAP,KAA0BV,cAA3C;AACAlE,0BAAQY,UAAR,CAAmB;AACjB,6BAASoD,OADQ;AAEjB,+BAAWS,OAFM;AAGjB,+BAAWR,SAHM;AAIjB,oCAAgBC;AAJC,mBAAnB;AAMD;AACD,oBAAIjB,GAAJ,EAAS;AACP,sBAAI4B,SAAS5B,IAAIlF,QAAJ,EAAb;AACAiC,0BAAQY,UAAR,CAAmB;AACjB,6BAASoD,UAAU,OAAV,GAAoBa,MAApB,GAA6B,QADrB;AAEjB,+BAAWJ,UAAUI,MAFJ;AAGjB,+BAAWZ,YAAYY,MAHN;AAIjB,oCAAgBX,iBAAiB,OAAjB,GAA2BW,MAA3B,GAAoC;AAJnC,mBAAnB;AAMD;AACF,eA/IW,CA+IV;AAEH,aAlNE,CAkND;AACH,WA1O0B,CA0OzB;AACF,aAAO,CAAC7E,OAAD,EAAUnE,UAAV,CAAP;AACD,K,CAAC;;;AAGF;;;;;;;;;;;;;;;;2CAauBiG,K,EAAOjG,U,EAAY;;AAExC,UAAImE,UAAU,IAAd;;AAEA;AACA,UAAIa,UAAU,KAAKC,YAAL,CAAkBgB,KAAlB,EAAyBjG,UAAzB,CAAd;AACA,UAAIiJ,WAAWjE,QAAQ,CAAR,CAAf;AACA,UAAIZ,cAAcY,QAAQ,CAAR,CAAlB;AACA,UAAIX,cAAcW,QAAQ,CAAR,CAAlB;;AAEA;;AAEA,UAAK,KAAK1G,UAAN,IAAsB,CAAC,KAAKQ,OAAL,CAAawB,QAAb,CAAsB,KAAKhC,UAA3B,CAA3B,EACE,KAAKQ,OAAL,CAAa2C,IAAb,CAAkB,KAAKnD,UAAvB;;AAEF;AACA;AACA;AACA;AACA;AACA,UAAI4K,SAAS,KAAKpK,OAAL,CAAaL,MAA1B;AACA,UAAI,CAAC2F,WAAD,IAAgB,CAACC,WAArB,EAAkC;AAChC,YAAI8E,cAAc,MAAMF,SAASjH,SAAT,CAAmB,CAAnB,EAAsBiH,SAASxK,MAAT,GAAkB,CAAxC,CAAN,GAAmD,GAArE;AACA,YAAI2K,YAAY,KAAK5H,SAAL,CAAe2H,WAAf,EAA4BnJ,UAA5B,CAAhB;;AAEA;AACA;AACA,YAAIoJ,UAAU,CAAV,CAAJ,EAAkB;AAChBjF,oBAAUiF,UAAU,CAAV,CAAV;AACApJ,uBAAaA,WAAWO,OAAX,CAAmB0I,QAAnB,EAA6BE,WAA7B,CAAb;AACA,eAAKrK,OAAL,CAAa2C,IAAb,CAAqBwH,QAAH,8CACbE,WADa,eACS,KAAKvK,WADd,IAEbuK,WAFa,UAEGhF,QAAQsC,KAFX,SAEoB,KAAK5H,SAFzB,CAAlB;AAGD;AACD;AAPA,aAQK;AACH;AACA,gBAAI,KAAKC,OAAL,CAAaL,MAAb,GAAsByK,MAA1B,EAAkC;AAChC,mBAAKpK,OAAL,CAAauK,GAAb;AACD;AACDpD,oBAAQ,CAAR;AACA9B,sBAAU,CAAV;AACD;AACF,OAtBD,CAsBE;;AAtBF,WAwBK;AACH;AACA;AACA;AACA,cAAIC,eAAe,CAACC,WAApB,EAAiC;AAC/B;AACA;AACA;AACA,gBAAI3G,UAAUiD,eAAV,CAA0ByD,WAA1B,CAAJ,EAA4C;AAC1CD,wBAAUC,WAAV;AACD;AACD;AAHA,iBAIK;AACH,oBAAIgF,aAAY,KAAK5H,SAAL,CAAe4C,WAAf,EAA4BpE,UAA5B,CAAhB;;AAEA;AACA,oBAAIoJ,WAAU,CAAV,CAAJ,EAAkB;AAChBjF,4BAAUiF,WAAU,CAAV,CAAV;AACAjF,0BAAQS,OAAR,IAAmBqE,QAAnB;AACAjJ,+BAAaoJ,WAAU,CAAV,CAAb;AACD;AACD;AALA,qBAMK;AACH,yBAAKtK,OAAL,CAAa2C,IAAb,CAAkB,+BAA6B2C,WAA7B,4CACW6E,QADX,OAAlB;AAED;AACF;AACF;AACD;AACA;AACA;AA1BA,eA2BK,IAAI,CAAC7E,WAAD,IAAgBC,WAApB,EAAiC;;AAEpC;AACA;AACA,kBAAI3G,UAAUiD,eAAV,CAA0B0D,WAA1B,CAAJ,EAA4C;AAC1CF,0BAAUE,cAAc4E,QAAxB;AACA,qBAAKnK,OAAL,CAAa2C,IAAb,CAAkB,qBAAkBwH,QAAlB,oCACb5E,WADa,IACiB,KAAKzF,WADtB,GACoCuF,OADpC,GAEhB,KAAKtF,SAFP;AAGD,eALD,MAMK;AACH,oBAAIuK,cAAY,KAAK5H,SAAL,CAAe6C,WAAf,EAA4BrE,UAA5B,CAAhB;AACA,oBAAIoJ,YAAU,CAAV,CAAJ,EAAkB;AAChBjF,4BAAUiF,YAAU,CAAV,CAAV;AACAjF,0BAAQS,OAAR,IAAmBqE,QAAnB;AACAjJ,+BAAamE,QAAQS,OAArB;AACA,uBAAK9F,OAAL,CAAa2C,IAAb,CAAkB,oBAAkBwH,QAAlB,gDACO,KAAKrK,WADZ,GAC0BuF,QAAQS,OADlC,GAEhB,KAAK/F,SAFP;AAGD;AACD;AARA,qBASK;AACH,yBAAKC,OAAL,CAAa2C,IAAb,CAAkB,+BAA6B2C,WAA7B,2CACU6E,QADV,OAAlB;AAED;AACF;AACF;AACD;AACA;AACA;AA7BK,iBA8BA;AACH,qBAAKnK,OAAL,CAAa2C,IAAb,CAAkB,+BAA6B2C,WAA7B,GAA2C6E,QAA3C,IACb5E,WADa,gGAAlB;AAGD;AACF,SA/GuC,CA+GtC;;AAEF,aAAO,CAACF,OAAD,EAAWnE,UAAX,CAAP;AAED,K,CAAC;;;AAGF;;;;;;;;;;;;;;;;;;2CAeuBc,M,EAAQd,U,EAAY;;AAEzC,UAAIU,YAAYI,OAAO,CAAP,EAAU,IAAV,CAAhB;AACA,UAAIpD,UAAUiD,eAAV,CAA0BD,SAA1B,CAAJ,EAA0C;AACxCA,oBAAY,IAAI7C,IAAJ,CAAS,EAAC,WAAY6C,SAAb;AACnB,wBAAeU,OAAOV,SAAP,CADI;AAEnB,mBAAUA,SAFS,EAAT,CAAZ;AAGD;AACD,UAAIO,OAAOH,OAAOrC,MAAlB;AACA,UAAI0B,gBAAgB,KAApB;AACA;AACA;AACA,WAAK,IAAImJ,KAAK,CAAd,EAAkBA,KAAKrI,IAAN,IAAe,CAACd,aAAjC,EAAgDmJ,IAAhD,EAAsD;AACpD,YAAIC,WAAWzI,OAAOwI,EAAP,EAAW,IAAX,CAAf;AACA,YAAI5L,UAAUiD,eAAV,CAA0B4I,QAA1B,CAAJ,EAAyC;AACvCA,qBAAW,IAAI1L,IAAJ,CAAS,EAAC,WAAY0L,QAAb;AAClB,0BAAenI,OAAOmI,QAAP,CADG;AAElB,qBAASA,QAFS,EAAT,CAAX;AAGD;AACD,YAAIA,aAAa,IAAb,IACE,OAAOA,QAAP,KAAoB,QAArB,IAAmC,CAACA,SAASzE,WADlD,EACiE;AAC/D,cAAI0E,YAAY,kBAAgBxJ,UAAhB,gCACA,SADhB;AAEA,cAAIuJ,QAAJ,EAAc;AACZC,yBAAa,OAAK,KAAKpL,SAAV,GAAsBmL,SAASrH,QAAT,EAAtB,IACG,KAAK7D,UADR,OAAb;AAED;AACDmL,uBAAa,uCAAb;AACA,eAAK1K,OAAL,CAAa2C,IAAb,CAAkB+H,SAAlB;AACArJ,0BAAgB,IAAhB;AACD,SAXD,MAYK;AACH,cAAI;AACF;AACA,gBAAIsJ,SAAS3I,OAAOwI,EAAP,EAAW,IAAX,CAAb;AACA,gBAAII,QAAQD,WAAW,GAAvB;;AAEA;AACA;AACAC,oBAAQhJ,YAAYA,UAAUiJ,MAAV,CAAiBJ,QAAjB,CAApB,GACQ7I,YAAYA,UAAUkJ,aAAV,CAAwBL,QAAxB,CADpB;AAED,WATD,CAUA,OAAOM,GAAP,EAAY;AACV,iBAAK/K,OAAL,CAAaqE,OAAb,CAAqB0G,IAAIC,OAAzB;AACA3J,4BAAgB,IAAhB;AACAO,wBAAY,IAAZ;AACD;AACF,SAnCmD,CAmClD;AACH,OAhDwC,CAgDvC;AACF,aAAOA,SAAP;AACD,K,CAAE;;;AAGH;;;;;;;;;;;;;;;;;;;;;;;;;;;wCAwBoBuF,K,EAAO;;AAEzB,UAAI8D,MAAM,EAAV;AACA,UAAI9C,MAAMhB,MAAMhD,KAAN,CAAY,0BAAZ,CAAV;;AAEA;AACA;AACA,UAAIgE,OAAOA,IAAI,CAAJ,CAAP,IAAiBA,IAAI,CAAJ,MAAW,EAAhC,EAAoC;AAClC8C,YAAItI,IAAJ,CAASwF,IAAI,CAAJ,CAAT;AACA8C,YAAItI,IAAJ,CAASwF,IAAI,CAAJ,CAAT;AACD,OAHD,CAGE;AAHF,WAIK;AACH8C,gBAAM,IAAN;AACD;AACD,aAAOA,GAAP;AACD,K,CAAC;;;;;KAEF;;;AAGF;;;;;;;;;;;;;AAWA/L,WAAWE,WAAX,GAAyB,YAAU;AACjC,SAAO,IAAIF,UAAJ,EAAP;AACD,CAFD;;AAIA","file":"unitString.js","sourcesContent":["/**\n * This class handles the parsing of a unit string into a unit object\n */\n\nvar Ucum = require('./config.js').Ucum;\nvar Unit = require('./unit.js').Unit;\nvar UnitTables = require('./unitTables.js').UnitTables;\nvar PrefixTables = require('./prefixTables.js').PrefixTables;\n\nimport * as intUtils_ from \"./ucumInternalUtils.js\";\n\nexport class UnitString {\n\n  /**\n   * Constructor\n   */\n  constructor() {\n\n    // Get instances of the unit and prefix tables and the utilities\n    this.utabs_ = UnitTables.getInstance();\n    this.pfxTabs_ = PrefixTables.getInstance();\n\n    // Set emphasis characters to defaults.  These are used to emphasize\n    // certain characters or strings in user messages.  They can be reset in\n    // the useHTMLInMessages method.\n    this.openEmph_ = Ucum.openEmph_;\n    this.closeEmph_ = Ucum.closeEmph_;\n\n    // Set the braces message to blank.  This message is displayed for each\n    // validation request on the web page, but is included separately as\n    // a note on the validation spreadsheet.  The useBraceMsgForEachString\n    // method should be used to set the message to be displayed for each\n    // unit string.\n    this.bracesMsg_ = '';\n\n    // Set the flags used, with indices, as place holders in unit strings\n    // for parenthetical strings and strings within braces.\n    this.parensFlag_ = \"parens_placeholder\"; // in lieu of Jehoshaphat\n    this.pFlagLen_ = this.parensFlag_.length;\n    this.braceFlag_ = \"braces_placeholder\"; // in lieu of Nebuchadnezzar\n    this.bFlagLen_ = this.braceFlag_.length;\n\n    // Initialize the message start/end strings, which will be set when\n    // parseString is called.\n    this.vcMsgStart_ = null;\n    this.vcMsgEnd_ = null;\n\n    // Arrays used by multiple methods within this class to hold persistent\n    // data.  Just gets too bulky to pass these guys around.\n\n    // Messages to be returned to the calling function\n    this.retMsg_ = [] ;\n\n    // Units for parenthetical unit strings\n    this.parensUnits_ = [] ;\n\n    // annotation text for annotations found in unit strings\n    this.annotations_ = [] ;\n\n    // suggestions for unit strings that for which no unit was found\n    this.suggestions = [] ;\n\n  } // end constructor\n\n\n  /**\n   * Sets the emphasis strings to the HTML used in the webpage display - or\n   * blanks them out, depending on the use parameter.\n   *\n   * @param use flag indicating whether or not to use the html message format;\n   *  defaults to true\n   */\n  useHTMLInMessages(use) {\n    if (use === undefined || use) {\n      this.openEmph_ = Ucum.openEmphHTML_;\n      this.closeEmph_ = Ucum.closeEmphHTML_;\n    }\n    else {\n      this.openEmph_ = Ucum.openEmph_;\n      this.closeEmph_ = Ucum.closeEmph_;\n    }\n  } // end useHTMLInMessages\n\n\n  /**\n   * Sets the braces message to be displayed for each unit string validation\n   * requested, as appropriate.\n   *\n   * @param use flag indicating whether or not to use the braces message;\n   *  defaults to true\n   */\n  useBraceMsgForEachString(use) {\n    if (use === undefined || use)\n      this.bracesMsg_ = Ucum.bracesMsg_;\n    else\n      this.bracesMsg_ = '';\n  }\n\n\n  /**\n   * Parses a unit string, returns a unit, a possibly updated version of\n   * the string passed in, and messages and suggestions where appropriate.\n   *\n   * The string returned may be updated if the input string contained unit\n   * names, e.g., \"pound\".  The unit code ([lb_av] for pound) is placed in\n   * the string returned, a the returned messages array includes a note\n   * explaining the substitution.\n   *\n   * @param uStr the string defining the unit\n   * @param valConv indicates what type of request this is for - a request to\n   *  validate (pass in 'validate') or a request to convert (pass in 'convert');\n   *  optional, defaults to 'validate'\n   * @param suggest a boolean to indicate whether or not suggestions are\n   *  requested for a string that cannot be resolved to a valid unit;\n   *  true indicates suggestions are wanted; false indicates they are not,\n   *  and is the default if the parameter is not specified;\n   * @returns an array containing:\n   *   the unit object or null if a unit could not be created.  In cases where\n   *     a fix was found for a problem string, .e.g., 2.mg for 2mg, a unit will\n   *     be returned but an error message will also be returned, describing\n   *     the substitution;\n   *   the possibly updated unit string passed in;\n   *   an array of any user messages (informational, error or warning)\n   *     generated (or an empty array); and\n   *   a suggestions array of hash objects (1 or more).  Each hash contains\n   *   three elements:\n   *     'msg' which is a message indicating what unit expression the\n   *       suggestions are for;\n   *     'invalidUnit' which is the unit expression the suggestions are\n   *       for; and\n   *     'units' which is an array of data for each suggested unit found.\n   *        Each array will contain the unit code, the unit name and the\n   *        unit guidance (if any).\n   *   The return array will not contain a suggestions array if a valid unit\n   *   was found or if suggestions were not requested.\n   * @throws an error if nothing was specified.\n   */\n  parseString(uStr, valConv, suggest) {\n\n    uStr = uStr.trim();\n    // Make sure we have something to work with\n    if (uStr === '' || uStr === null) {\n      throw (new Error('Please specify a unit expression to be validated.'));\n    }\n\n    if (valConv === 'validate') {\n      this.vcMsgStart_ = Ucum.valMsgStart_;\n      this.vcMsgEnd_ = Ucum.valMsgEnd_;\n    }\n    else {\n      this.vcMsgStart_ = Ucum.cnvMsgStart_;\n      this.vcMsgEnd_ = Ucum.cnvMsgEnd_;\n    }\n\n    if (suggest === undefined || suggest === false) {\n      this.suggestions_ = null;\n    }\n    else {\n      this.suggestions_ = [] ;\n    }\n    this.retMsg_ = [];\n    this.parensUnits_ = [];\n    this.annotations_ = [] ;\n\n    let origString = uStr;\n    let retObj = [];\n\n    // Extract any annotations, i.e., text enclosed in braces ({}) from the\n    // string before further processing.  Store each one in this.annotations_\n    // array and put a placeholder in the string for the annotation.  Do\n    // this before other processing in case an annotation contains characters\n    // that will be interpreted as parenthetical markers or operators in\n    // subsequent processing.\n\n    uStr = this._getAnnotations(uStr);\n    if (this.retMsg_.length > 0) {\n      retObj[0] = null;\n      retObj[1] = null;\n    }\n    else {\n      // Flag used to block further processing on an unrecoverable error\n      let endProcessing = this.retMsg_.length > 0;\n\n      // First check for one of the \"special\" units.  If it's one of those, put\n      // in a substitution phrase for it to avoid having it separated on its\n      // embedded operator.  This will only happen, by the way, if it is\n      // preceded by a prefix or followed by an operator and another unit.\n      let sUnit = null ;\n      for (sUnit in Ucum.specUnits_) {\n        while (uStr.includes(sUnit))\n          uStr = uStr.replace(sUnit, Ucum.specUnits_[sUnit]);\n      }\n\n      // Check for spaces and throw an error if any are found.  The spec\n      // explicitly forbids spaces except in annotations, which is why any\n      // annotations are extracted before this check is made.\n      if (uStr.indexOf(' ') > -1) {\n        throw (new Error('Blank spaces are not allowed in unit expressions.'));\n      } // end if blanks were found in the string\n\n      // assign the array returned to retObj.  It will contain 2 elements:\n      //  the unit returned in position 0; and the origString (possibly\n      //  modified in position 1.  The origString in position 1 will not\n      //  be changed by subsequent processing.\n      retObj = this._parseTheString(uStr, origString);\n      let finalUnit = retObj[0];\n\n      // Do a final check to make sure that finalUnit is a unit and not\n      // just a number.  Something like \"8/{HCP}\" will return a \"unit\" of 8\n      // - which is not a unit.  Hm - evidently it is.  So just create a unit\n      // object for it.\n      if (intUtils_.isNumericString(finalUnit) || typeof finalUnit === 'number') {\n        finalUnit = new Unit({\n          'csCode_': origString,\n          'magnitude_': finalUnit,\n          'name_': origString\n        });\n        retObj[0] = finalUnit;\n      } // end final check\n    } // end if no annotation errors were found\n\n    retObj[2] = this.retMsg_;\n    if (this.suggestions_ && this.suggestions_.length > 0)\n      retObj[3] = this.suggestions_ ;\n    return retObj;\n\n  } // end parseString\n\n\n  /**\n   * Parses a unit string, returns a unit, a possibly updated version of\n   * the string passed in, and messages where appropriate.  This should\n   * only be called from within this class (or by test code).\n   *\n   * The string returned may be updated if the input string contained unit\n   * names, e.g., \"pound\".  The unit code ([lb_av] for pound) is placed in\n   * the string returned, a the returned messages array includes a note\n   * explaining the substitution.\n   *\n   * @param uStr the string defining the unit\n   * @param origString the original unit string passed in\n   * @returns\n   *  an array containing:\n   *    the unit object (or null if there were problems creating the unit); and\n   *    the possibly updated unit string passed in.\n   *\n   * the this.retMsg_ array will be updated with any user messages\n   *   (informational, error or warning) generated by this or called methods\n   * the this.parensUnits_ array is referenced and possibly populated by\n   *   methods called within this one\n   * the this.annotations_ array is referenced by methods called within\n   *   this one\n   * the this.suggestions_ array may be populated by methods called within\n   *   this one\n   */\n  _parseTheString(uStr, origString) {\n\n    // Unit to be returned\n    let finalUnit = null;\n\n    // Flag used to block further processing on an unrecoverable error\n    let endProcessing = this.retMsg_.length > 0;\n\n    // Call _processParens to search for and process any/all parenthetical\n    // strings in uStr.  Units created for parenthetical strings will be\n    // stored in the this.parensUnits_ array.\n    let parensResp = this._processParens(uStr, origString);\n    endProcessing = parensResp[2];\n\n    // The array used to hold the units and their operators.\n    let uArray = [];\n\n    // Continue if we didn't hit a problem\n    if (!endProcessing) {\n      uStr = parensResp[0];\n      origString = parensResp[1];\n\n      // Call _makeUnitsArray to convert the string to an array of unit\n      // descriptors with operators.\n      let mkUArray = this._makeUnitsArray(uStr, origString);\n\n      endProcessing = mkUArray[2] ;\n      if (!endProcessing) {\n        uArray = mkUArray[0];\n        origString = mkUArray[1];\n        // Create a unit object out of each un element\n        let uLen = uArray.length;\n        for (let u1 = 0; u1 < uLen; u1++) {\n          //for (let u1 = 0; u1 < uLen && !endProcessing; u1++) {\n          let curCode = uArray[u1]['un'];\n\n          // Determine the type of the \"un\" attribute of the current array element\n\n          // Check to see if it's a number.  If so write the number version of\n          // the number back to the \"un\" attribute and move on\n          if (intUtils_.isNumericString(curCode)) {\n            uArray[u1]['un'] = Number(curCode);\n          }\n\n          else {\n            // The current unit array element is a string.  Check now to see\n            // if it is or contains a parenthesized unit from this.parensUnits_.\n            // If so, call _getParens to process the string and get the unit.\n\n            if (curCode.indexOf(this.parensFlag_) >= 0) {\n              let parenUnit = this._getParensUnit(curCode, origString);\n              // if we couldn't process the string, set the end flag and bypass\n              // further processing.\n              if (!endProcessing)\n                endProcessing = parenUnit[1];\n\n              // If we're good, put the unit in the uArray and replace the\n              // curCode, which contains the parentheses placeholders, etc.,\n              // with the unit's code - including any substitutions.\n              if (!endProcessing) {\n                uArray[u1]['un'] = parenUnit[0];\n              }\n            } // end if the curCode contains a parenthesized unit\n\n            // Else it's not a parenthetical unit and not a number. Call\n            // _makeUnit to create a unit for it.\n            else {\n              let uRet = this._makeUnit(curCode, origString);\n              // If we didn't get a unit, set the endProcessing flag.\n              if (uRet[0] === null) {\n                endProcessing = true;\n              }\n              else {\n                uArray[u1]['un'] = uRet[0];\n                origString = uRet[1];\n              }\n            } // end if the curCode is not a parenthetical expression\n          } // end if the \"un\" array is a not a number\n        } // end do for each element in the units array\n      } // end if _makeUnitsArray did not return an error\n    } // end if _processParens did not find an error that causes a stop\n\n    // If we're still good, continue\n    if (!endProcessing) {\n      // Process the units (and numbers) to create one final unit object\n      if ((uArray[0] === null || uArray[0] === ' ' ||\n           uArray[0]['un'] === undefined || uArray[0]['un'] === null)\n          && this.retMsg_.length === 0) {\n        // not sure what this might be, but this is a safeguard\n        this.retMsg_.push(`Unit string (${origString}) did not contain ` +\n          `anything that could be used to create a unit, or else something ` +\n          `that is not handled yet by this package.  Sorry`);\n        endProcessing = true;\n      }\n    }\n    if (!endProcessing) {\n      finalUnit = this._performUnitArithmetic(uArray, origString);\n    }\n    return [finalUnit, origString];\n  } // end _parseTheString\n\n\n  /**\n   * Extracts all annotations from a unit string, replacing them with\n   * placeholders for later evaluation.  The annotations are stored in the\n   * this.annotations_ array.  This should only be called from within this\n   * class (or by test code).\n   *\n   * @param uString the unit string being parsed\n   * @returns the string after the annotations are replaced with placeholders\n   *\n   * the this.retMsg_ array will be updated with any user messages\n   *   (informational, error or warning) generated by this or called methods\n   * the this.annotations_ array is populated by this method\n   */\n  _getAnnotations(uString) {\n    let openBrace = uString.indexOf('{');\n    while (openBrace >= 0) {\n\n      let closeBrace = uString.indexOf('}');\n      if (closeBrace < 0) {\n        this.retMsg_.push('Missing closing brace for annotation starting at ' +\n          this.openEmph_ + uString.substr(openBrace) +\n          this.closeEmph_);\n        openBrace = -1;\n      }\n      else {\n        let braceStr = uString.substring(openBrace, closeBrace + 1);\n        let aIdx = this.annotations_.length.toString();\n        uString = uString.replace(braceStr, this.braceFlag_ + aIdx +\n          this.braceFlag_);\n        this.annotations_.push(braceStr);\n        openBrace = uString.indexOf('{');\n      }\n    } // end do while we have an opening brace\n\n    // check for a stray/unmatched closing brace\n    let closeBrace = uString.indexOf('}');\n    if (closeBrace >= 0)\n      this.retMsg_.push('Missing opening brace for closing brace found at ' +\n        this.openEmph_ + uString.substring(0, closeBrace + 1) +\n        this.closeEmph_);\n    return uString;\n  } // end _getAnnotations\n\n\n  /**\n   * Finds and processes any/all parenthesized unit strings. This should only\n   * be called from within this class (or by test code).\n   *\n   * Nested parenthesized strings are processed from the inside out.  The\n   * parseString function is called from within this one for each parenthesized\n   * unit string, and the resulting unit object is stored in this.parensUnits_,\n   * to be processed after all strings are translated to units.\n   *\n   * A placeholder is placed in the unit string returned to indicate that the\n   * unit object should be obtained from the this.parensUnits_ array.  The\n   * placeholder consists of the parenthesis flag (this.parensFlag_) followed\n   * by the index of the unit in this.parensUnits_ followed by this.parensFlag_.\n   *\n   * @param uString the unit string being parsed, where this will be the full\n   *  string the first time this is called and parenthesized strings on any\n   *  subsequent calls\n   * @param origString the original string first passed in to parseString\n   * @returns\n   *  an array containing:\n   *   the string after the parentheses are replaced;\n   *   the original string; and\n   *   a boolean flag indicating whether or not an error occurred that\n   *     should stop processing.\n   *\n   * the this.retMsg_ array will be updated with any user messages\n   *   (informational, error or warning) generated by this or called methods\n   * this this.parensUnits_ array will be populated with units found for\n   *   parenthetical unit strings\n   */\n  _processParens(uString, origString) {\n\n    // Unit strings array and index\n    let uStrArray = [];\n    let uStrAryPos = 0;\n    let stopProcessing = false;\n\n    let pu = this.parensUnits_.length;\n\n    // Count of characters trimmed off the beginning of the unit string (uString)\n    // as units are removed from it; used for error messages to provide\n    // context.\n    let trimmedCt = 0;\n\n    // Break the unit string into pieces that consist of text outside of\n    // parenthetical strings and placeholders for the parenthetical units.\n    // This method is called recursively for parenthetical strings and the units\n    // returned are stored in the this.parensUnits_ array.\n    while (uString !== \"\" && !stopProcessing) {\n      let openCt = 0;\n      let closeCt = 0;\n      let openPos = uString.indexOf('(');\n\n      // If an opening parenthesis was not found, check for an unmatched\n      // close parenthesis.  If one was found report the error and end\n      // processing.\n      if (openPos < 0) {\n        let closePos = uString.indexOf(')');\n        if (closePos >= 0) {\n          let theMsg = `Missing open parenthesis for close ` +\n            `parenthesis at ${uString.substring(0, closePos + trimmedCt)}` +\n            `${this.openEmph_}${uString.substr(closePos, 1)}${this.closeEmph_}`;\n          if (closePos < uString.length - 1) {\n            theMsg += `${uString.substr(closePos + 1)}`;\n          }\n          this.retMsg_.push(theMsg);\n          uStrArray[uStrAryPos] = uString;\n          stopProcessing = true;\n        } // end if a close parenthesis was found\n\n        // If no parentheses were found in the current unit string, transfer\n        // it to the units array and blank out the string, which will end\n        // the search for parenthetical units.\n        else {\n          uStrArray[uStrAryPos] = uString;\n          uString = \"\";\n        } // end if no close parenthesis was found\n      } // end if no open parenthesis was found\n\n      // Otherwise an open parenthesis was found. Process the string that\n      // includes the parenthetical group\n      else {\n        openCt += 1;\n        // Write the text before the parentheses (if any) to the unit strings array\n        let uLen = uString.length;\n        if (openPos > 0) {\n          uStrArray[uStrAryPos++] = uString.substr(0, openPos);\n        }\n\n        // Find the matching closePos, i.e., the one that closes the\n        // parenthetical group that this one opens.  Look also for\n        // another open parenthesis, in case this includes nested parenthetical\n        // strings.  This continues until it finds the same number of close\n        // parentheses as open parentheses, or runs out of string to check.\n        // In the case of nested parentheses this will identify the outer set\n        // of parentheses.\n        let closePos = 0;\n        let c = openPos + 1;\n        for (; c < uLen && openCt != closeCt; c++) {\n          if (uString[c] === '(')\n            openCt += 1;\n          else if (uString[c] === ')')\n            closeCt += 1;\n        }\n\n        // Put a placeholder for the group in the unit strings array and recursively\n        // call this method for the parenthetical group.  Put the unit returned\n        // in this.parensUnits_.  Set the unit string to whatever follows\n        // the position of the closing parenthesis for this group, to be\n        // processed by the next iteration of this loop.  If there's nothing\n        // left uString is set to \"\".\n        if (openCt === closeCt) {\n          closePos = c;\n          uStrArray[uStrAryPos++] = this.parensFlag_ + pu.toString() + this.parensFlag_;\n          let parseResp = this._parseTheString(\n            uString.substring(openPos + 1, closePos - 1), origString);\n          if (parseResp[0] === null)\n            stopProcessing = true;\n          else {\n            origString = parseResp[1];\n            this.parensUnits_[pu++] = parseResp[0];\n            uString = uString.substr(closePos);\n            trimmedCt = closePos;\n          }\n        } // end if the number of open and close parentheses matched\n\n        // If the number of open and close parentheses doesn't match, indicate\n        // an error.\n        else {\n          uStrArray.push(origString.substr(openPos));\n          this.retMsg_.push(`Missing close parenthesis for open parenthesis at ` +\n            `${origString.substring(0, openPos + trimmedCt)}` +\n            `${this.openEmph_}${origString.substr(openPos, 1)}` +\n            `${this.closeEmph_}${origString.substr(openPos + 1)}`);\n          stopProcessing = true;\n        }\n      } // end if an open parenthesis was found\n    } // end do while the input string is not empty\n    if (stopProcessing)\n      this.parensUnits_ = [];\n    return [uStrArray.join(''), origString, stopProcessing]\n  } // end _processParens\n\n\n  /**\n   * Breaks the unit string into an array of unit descriptors and operators.\n   * If a unit descriptor consists of a number preceding a unit code, with\n   * no multiplication operator, e.g., 2mg instead of 2.mg, it is handled\n   * as if it were a parenthetical expression.\n   *\n   * This should only be called from within this class (or by test code).\n   *\n   * @param uStr the unit string being parsed\n   * @param origString the original string passed to parseString\n   * @returns\n   *  an array containing:\n   *    the array representing the unit string;\n   *    the original string passed in, possibly updated with corrections; and\n   *    and a flag indicating whether or not processing can continue.\n   *\n   * the this.retMsg_ array will be updated with any user messages\n   *   (informational, error or warning) generated by this or called methods\n   */\n  _makeUnitsArray(uStr, origString) {\n\n    // Separate the string into pieces based on delimiters / (division) and .\n    // (multiplication).  The idea is to get an array of units on which we\n    // can then perform any operations (prefixes, multiplication, division).\n\n    let uArray1 = uStr.match(/([./]|[^./]+)/g);\n    let endProcessing = false ;\n    let uArray = [];\n    let startNumCheck = /(^[0-9]+)(\\[?[a-zA-Z\\_0-9a-zA-Z\\_]+\\]?$)/ ;\n\n    // If the first element in the array is the division operator (/), the\n    // string started with '/'.  Add a first element containing 1 to the\n    // array, which will cause the correct computation to be performed (inversion).\n    if (uArray1[0] === \"/\") {\n      uArray1.unshift(\"1\");\n    }\n    // If the first element in the array is the multiplication operator (.)\n    // return an error.\n    else if (uArray1[0] === '.') {\n      this.retMsg_.push(`${origString} is not a valid UCUM code. ` +\n          `The multiplication operator at the beginning of the expression is ` +\n          `not valid. A multiplication operator must appear only between ` +\n          `two codes.`);\n      endProcessing = true ;\n    }\n    if (!endProcessing) {\n      // Check to see if there is a number preceding a unit code, e.g., 2mg\n      // If so, update the first element to remove the number (2mg -> mg) and\n      // add two elements to the beginning of the array - the number and the\n      // multiplication operator.\n\n      if (!intUtils_.isNumericString(uArray1[0])) {\n        let numRes = uArray1[0].match(startNumCheck);\n        if (numRes && numRes.length === 3 && numRes[1] !== '' &&\n          numRes[2] !== '' && numRes[2].indexOf(this.braceFlag_) !== 0) {\n          let dispVal = numRes[2] ;\n\n          if (!endProcessing && numRes[2].includes(this.parensFlag_)) {\n            let parensback = this._getParensUnit(numRes[2], origString);\n            numRes[2] = parensback[0]['csCode_'];\n            dispVal = `(${numRes[2]})`;\n            endProcessing = parensback[1];\n          }\n          if (!endProcessing) {\n            this.retMsg_.push(`${numRes[1]}${dispVal} is not a valid UCUM code.` +\n              `  ${this.vcMsgStart_}${numRes[1]}.${dispVal}${this.vcMsgEnd_}`);\n            origString = origString.replace(`${numRes[1]}${dispVal}`,\n              `${numRes[1]}.${dispVal}`);\n            uArray1[0] = numRes[2];\n            uArray1.unshift(numRes[1], '.');\n          }\n        }\n      } // end if the first element is not a number (only)\n\n      // Create an array of unit/operator objects.  The unit is, for now, the\n      // string containing the unit code (e.g., Hz for hertz) including\n      // a possible prefix and exponent.   The operator is the operator to be\n      // applied to that unit and the one preceding it.  So, a.b would give\n      // us two objects.  The first will have a unit of a, and a blank operator\n      // (because it's the first unit).  The second would have a unit of b\n      // and the multiplication operator (.).\n      if (!endProcessing) {\n        let u1 = uArray1.length;\n        uArray = [{op: \"\", un: uArray1[0]}];\n        for (let n = 1; n < u1; n++) {\n\n          // check to make sure that we don't have two operators together, e.g.,\n          // mg./K.  If so, let the user know the problem.\n          let theOp = uArray1[n++];\n          // oh wait - check to make sure something is even there, that the\n          // user didn't end the expression with an operator.\n          if (!uArray1[n]) {\n            this.retMsg_.push(`${origString} is not a valid UCUM code. ` +\n              `It is terminated with the operator ${this.openEmph_}` +\n              `${theOp}${this.closeEmph_}.`);\n            n = u1;\n            endProcessing = true;\n          }\n          else if (Ucum.validOps_.includes(uArray1[n])) {\n            this.retMsg_.push(`${origString} is not a valid UCUM code. ` +\n              `A unit code is missing between${this.openEmph_}` +\n              `${theOp}${this.closeEmph_}and${this.openEmph_}` +\n              `${uArray1[n]}${this.closeEmph_}in${this.openEmph_}` +\n              `${theOp}${uArray1[n]}${this.closeEmph_}.`);\n            n = u1;\n            endProcessing = true;\n          }\n          else {\n            // Check to see if a number precedes a unit code.\n            // If so, send the element to _processParens, inserting the multiplication\n            // operator where it belongs.  Treating it as parenthetical keeps it from\n            // being interpreted incorrectly because of operator parentheses.  For\n            // example, if the whole string is mg/2kJ we don't want to rewrite it as\n            // mg/2.kJ - because mg/2 would be performed, followed by .kJ.  Instead,\n            // handling 2kJ as a parenthesized unit will make sure mg is divided by\n            // 2.kJ.\n            if (!intUtils_.isNumericString(uArray1[n])) {\n              let numRes2 = uArray1[n].match(startNumCheck);\n              if (numRes2 && numRes2.length === 3 && numRes2[1] !== '' &&\n                numRes2[2] !== '' && numRes2[2].indexOf(this.braceFlag_) !== 0) {\n                let invalidString = numRes2[0];\n                if (!endProcessing && numRes2[2].includes(this.parensFlag_)) {\n                  let parensback = this._getParensUnit(numRes2[2], origString);\n                  numRes2[2] = parensback[0]['csCode_'];\n                  invalidString = `(${numRes2[2]})`;\n                  endProcessing = parensback[1];\n                  if (!endProcessing) {\n                    this.retMsg_.push(`${numRes2[1]}${invalidString} is not a ` +\n                      `valid UCUM code.  ${this.vcMsgStart_}${numRes2[1]}.${invalidString}` +\n                      `${this.vcMsgEnd_}`);\n                    let parensString = `(${numRes2[1]}.${invalidString})`;\n                    origString = origString.replace(`${numRes2[1]}${invalidString}`,\n                      parensString);\n                    let nextParens = this._processParens(parensString, origString);\n                    endProcessing = nextParens[2];\n                    if (!endProcessing) {\n                      uArray.push({op: theOp, un: nextParens[0]});\n                    }\n                    //uArray.push({op: '.', un: numRes2[2]});\n                  }\n                } // end if the string represents a parenthesized unit\n                else {\n                  let parensStr = '(' + numRes2[1] + '.' + numRes2[2] + ')';\n                  let parensResp = this._processParens(parensStr, origString);\n                  // if a \"stop processing\" flag was returned, set the n index to end\n                  // the loop and set the endProcessing flag\n                  if (parensResp[2]) {\n                    n = u1;\n                    endProcessing = true;\n                  }\n                  else {\n                    this.retMsg_.push(`${numRes2[0]} is not a ` +\n                      `valid UCUM code.  ${this.vcMsgStart_}${numRes2[1]}.${numRes2[2]}` +\n                      `${this.vcMsgEnd_}`);\n                    origString = origString.replace(numRes2[0], parensStr);\n                    uArray.push({op: theOp, un: parensResp[0]});\n                  } // end if no error on the processParens call\n                } // end if the string does not represent a parenthesized unit\n              } // end if the string is a number followed by a string\n              else {\n                uArray.push({op: theOp, un: uArray1[n]});\n              }\n            }\n            else {\n              uArray.push({op: theOp, un: uArray1[n]});\n            }\n          } // end if there isn't a missing operator or unit code\n        } // end do for each element in uArray1\n      } // end if a processing error didn't occur in getParensUnit\n    } // end if the string did not begin with a '.' with no following digit\n    return [uArray, origString, endProcessing];\n  } // end _makeUnitsArray\n\n\n  /**\n   * Takes a unit string containing parentheses flags and returns the unit they\n   * represent.  Any text found before and/or after the parenthetical\n   * expression is checked to see if we can tell what the user meant and\n   * let them know what it should have been.  For example, 2(mg), which\n   * would resolve to 2mg, should be 2.mg.\n   *\n   * This should only be called from within this class (or by test code).\n   *\n   * @param pStr the string being parsed\n   * @param origString the original unit string passed in; passed through\n   *  to _getAnnonText if annotation flags are found in any text preceding\n   *  or following the parenthetical unit\n   * @returns\n   *   an array containing\n   *     the unit object; and\n   *     a flag indicating whether or not processing should be ended.\n   *       True indicates that the string was invalid and no corrections\n   *         (substitutions or suggestions) could be found;\n   *       False indicates that it was either valid or substitutions/suggestions\n   *          were made.\n   *   the this.retMsg_ array will be updated with any user messages\n   *     (informational, error or warning) generated by this or called methods\n   *   this this.parensUnits_ array contains the units that are acquired by\n   *     this method\n   * @throws an error if an invalid parensUnit index was found.  This is\n   *    a processing error.\n   */\n  _getParensUnit(pStr, origString) {\n    let endProcessing = false;\n    let retAry = [];\n    let retUnit = null;\n    let befAnnoText = null;\n    let aftAnnoText = null;\n\n    // Get the location of the flags.  We're assuming there are only two\n    // because _processParens takes care of nesting.  By the time we get\n    // here we should not be looking a nested parens.  Also get any text\n    // before and after the parentheses.  Once we get the unit we update\n    // the input string with the unit's csCode_, which will wipe out any\n    // before and after text\n    let psIdx = pStr.indexOf(this.parensFlag_);\n    let befText = null;\n    if (psIdx > 0) {\n      befText = pStr.substr(0, psIdx - 1);\n    }\n    let peIdx = pStr.lastIndexOf(this.parensFlag_);\n    let aftText = null;\n    if (peIdx + this.pFlagLen_ < pStr.length) {\n      aftText = pStr.substr(peIdx + this.pFlagLen_);\n    }\n\n    // Get the text between the flags\n    let pNumText = pStr.substring(psIdx + this.pFlagLen_, peIdx);\n\n    // Make sure the index is a number, and if it is, get the unit from the\n    // this.parensUnits_ array\n    if (intUtils_.isNumericString(pNumText)) {\n      retUnit = this.parensUnits_[Number(pNumText)];\n      if (!intUtils_.isNumericString(retUnit)) {\n        pStr = retUnit.csCode_;\n      }\n      else {\n        pStr = retUnit ;\n      }\n    }\n    // If it's not a number, it's a programming error.  Throw a fit.\n    else {\n      throw (new Error(`Processing error - invalid parens number ${pNumText} ` +\n        `found in ${pStr}.`));\n    }\n\n    // If there's something in front of the starting parentheses flag, check to\n    // see if it's a number or an annotation.\n    if (befText) {\n      // If it's a number, assume that multiplication was assumed\n      if (intUtils_.isNumericString(befText)) {\n        let nMag = retUnit.getProperty('magnitude_');\n        nMag *= Number(befText);\n        retUnit.assignVals({'magnitude_': nMag});\n        pStr = `${befText}.${pStr}`;\n        this.retMsg_.push(`${befText}${pStr} is not a valid UCUM code.\\n` +\n          this.vcMsgStart_ + pStr + this.vcMsgEnd_);\n      }\n      else {\n        if (befText.indexOf(this.braceFlag_) >= 0) {\n          let annoRet = this._getAnnoText(befText, origString);\n          // if we found not only an annotation, but text before or after\n          // the annotation (remembering that this is all before the\n          // parentheses) throw an error - because we don't know what\n          // to do with it.  Could it be missing an operator?\n          if (annoRet[1] || annoRet[2]) {\n            throw (new Error(`Text found before the parentheses (` +\n              `${befText}) included an annotation along with other text ` +\n              `for parenthetical unit ${retUnit.csCode_}`));\n          }\n          // Otherwise put the annotation after the unit string and note\n          // the misplacement.\n          pStr += annoRet[0];\n          this.retMsg_.push(`The annotation ${annoRet[0]} before the unit ` +\n            `code is invalid.\\n` + this.vcMsgStart_ + pStr + this.vcMsgEnd_);\n        }\n        // else the text before the parentheses is neither a number nor\n        // an annotation.  If suggestions were NOT requested, record an\n        // error.\n        else if (!this.suggestions_) {\n          this.retMsg_.push(`${befText} preceding the unit code ${pStr} ` +\n            `is invalid.  Unable to make a substitution.`);\n          endProcessing = true;\n        }\n        // otherwise try for suggestions\n        else {\n          let suggestStat = this._getSuggestions(befText);\n          endProcessing =  (suggestStat !== 'succeeded');\n\n        } // end if a brace was found or, if not, suggestions were not or\n          // were requested\n      } // end if text preceding the parentheses was not a number\n    } // end if there was text before the parentheses\n\n    // Process any text after the parentheses\n    if (aftText) {\n      // if it's an annotation, get it and add it to the pStr\n      if (aftText.indexOf(this.braceFlag_) >= 0) {\n        let annoRet = this._getAnnoText(aftText, origString);\n        // if we found not only an annotation, but text before or after\n        // the annotation (remembering that this is all after the\n        // parentheses) throw an error - because we don't know what\n        // to do with it.  Could it be missing an operator?\n        if (annoRet[1] || annoRet[2]) {\n          throw (new Error(`Text found after the parentheses (` +\n            `${aftText}) included an annotation along with other text ` +\n            `for parenthetical unit ${retUnit.csCode_}`));\n        }\n        // Otherwise put the annotation after the unit string - no message\n        // needed.\n        pStr += annoRet[0];\n      }\n      // Otherwise check to see if it's an exponent.  If so, warn the\n      // user that it's not valid - but try it anyway\n      else {\n\n        if (intUtils_.isNumericString(aftText)) {\n          pStr += aftText;\n          retUnit = retUnit.power(Number(aftText));\n          this.retMsg_.push(`An exponent (${aftText}) following a parenthesis ` +\n            `is invalid as of revision 1.9 of the UCUM Specification.\\n  ` +\n            this.vcMsgStart_ + pStr + this.vcMsgEnd_);\n        }\n        // else the text after the parentheses is neither a number nor\n        // an annotation.  If suggestions were NOT requested, record an\n        // error.\n        else if (!this.suggestions_) {\n          this.retMsg_.push(`Text ${aftText} following the unit code ${pStr} ` +\n            `is invalid.  Unable to make a substitution.`);\n          endProcessing = true;\n        }\n        // otherwise try for suggestions\n        else {\n          let suggestStat = this._getSuggestions(befText);\n          endProcessing =  (suggestStat !== 'succeeded');\n        } // end if text following the parentheses not an exponent\n      } // end if text following the parentheses is not an annotation\n    } // end if there is text following the parentheses\n    if (!endProcessing) {\n      if (!retUnit) {\n        retUnit = new Unit({\n          'csCode_': pStr,\n          'magnitude_': 1,\n          'name_': pStr});\n      }\n      else if (intUtils_.isNumericString(retUnit)) {\n        retUnit = new Unit({'csCode_': retUnit,\n        'magnitude_': retUnit,\n        'name_': retUnit});\n      }\n      else {\n        retUnit.csCode_ = pStr;\n      }\n    }\n    return [retUnit, endProcessing];\n  } // end _getParensUnit\n\n  /**\n   * Takes a unit string containing annotation flags and returns the\n   * annotation they represent.  This also returns any text found before\n   * the annotation and any found after the annotation.\n   *\n   * This should only be called from within this class (or by test code).\n   * NEEDS FIX in next branch to handle string with multiple annotations.\n   *\n   * @param pStr the string being parsed\n   * @param origString the original string being parsed; used in error msg\n   *  thrown for an invalid index to the annotations array\n   * @returns\n   *  an array containing\n   *    the annotation for the pStr;\n   *    any text found before the annotation; and\n   *    any text found after the annotation.\n   *\n   * the this.retMsg_ array will be updated with any user messages\n   *   (informational, error or warning) generated by this or called methods\n   * the this.annotations_ array is used as the source for the annotations text\n   * @throws an error if for a processing error - an invalid annotation index.\n   */\n  _getAnnoText(pStr, origString) {\n\n    // if the starting braces flag is not at index 0, get the starting\n    // text and the adjust the pStr to omit it.\n    let asIdx = pStr.indexOf(this.braceFlag_);\n    let startText = (asIdx > 0) ? pStr.substring(0, asIdx) : null;\n    if (asIdx !== 0) {\n      pStr = pStr.substr(asIdx);\n    }\n\n    // Get the location of the end flag and, if text follows it, get the text\n    let aeIdx = pStr.indexOf(this.braceFlag_, 1);\n    let endText = ((aeIdx + this.bFlagLen_) < pStr.length) ?\n      pStr.substr(aeIdx + this.bFlagLen_) : null;\n\n    // Get the index of the annotation in this.annotations_.\n    // Check it to make sure it's valid, and if not, throw an error\n    let idx = pStr.substring(this.bFlagLen_, aeIdx);\n    let idxNum = Number(idx);\n    if (!intUtils_.isNumericString(idx) || idxNum >= this.annotations_.length) {\n      throw (new Error(`Processing Error - invalid annotation index ${idx} found ` +\n        `in ${pStr} that was created from ${origString}`));\n    }\n\n    // Replace the flags and annotation index with the annotation expression\n    pStr = this.annotations_[idxNum];\n    return [pStr, startText, endText];\n  } // end _getAnnoText\n\n\n  /**\n   * Takes a unit string and looks for suggested units.  This should be\n   * called for unit strings that cannot be resolved to unit codes.  The\n   * string is searched for in the synonyms table found in the UnitTables\n   * class.  That table includes all synonyms and unit names for the units\n   * in the unit data table.\n   *\n   * @param pStr the string being parsed\n   * @returns an object that contains an element named 'status', whose\n   *  value indicates the status of the request:\n   *   'succeeded' indicates that synonyms were found;\n   *   'failed' indicates that no synonyms were found; or\n   *   'error' which indicates that an error occurred\n   *\n   * the this.retMsg_ array will be updated with a message indicating whether\n   *  or not synonyms/suggestions  were found\n   * the this.suggestions_ array will be updated with a hash (added to the\n   *   array if it already contains others) that contains three elements:\n   *   'msg' which is a message indicating what unit expression the\n   *      suggestions are for;\n   *   'invalidUnit' which is the unit expression the suggestions are for; and\n   *   'units' which is an array of data for each suggested unit found.\n   *       Each array will contain the unit code, the unit name and the\n   *       unit guidance (if any).\n   */\n  _getSuggestions(pStr) {\n\n    let retObj = intUtils_.getSynonyms(pStr);\n    if (retObj['status'] === 'succeeded') {\n      let suggSet = {} ;\n      suggSet['msg'] = `${pStr} is not a valid UCUM code.  We found possible ` +\n                       `units that might be what was meant:`;\n      suggSet['invalidUnit'] = pStr ;\n      let synLen = retObj['units'].length ;\n      suggSet['units'] = [] ;\n      for (let s = 0; s < synLen; s++) {\n        let unit = retObj['units'][s];\n        let unitArray = [unit['code'], unit['name'], unit['guidance']];\n\n        suggSet['units'].push(unitArray) ;\n      }\n      this.suggestions_.push(suggSet);\n    }\n    else {\n      this.retMsg_.push(`${pStr} is not a valid UCUM code.  No alternatives ` +\n                  `were found.`);\n    }\n    return retObj['status'] ;\n  } // end getSuggestions\n\n\n  /**\n   * Creates a unit object from a string defining one unit.  The string\n   * should consist of a unit code for a unit already defined (base or\n   * otherwise).  It may include a prefix and an exponent, e.g., cm2\n   * (centimeter squared).  This should only be called from within this\n   * class (or by test code).\n   *\n   * @params uCode the string defining the unit\n   * @param origString the original string to be parsed; used to provide\n   *  context for messages\n   * @returns\n   *  an array containing:\n   *    a unit object, or null if there were problems creating the unit; and\n   *    the origString passed in, which may be updated if a unit name was\n   *    translated to a unit code.\n   *\n   *  the this.retMsg_ array will be updated with any user messages\n   *    (informational, error or warning) generated by this or called methods\n   *  the this.suggestions_ array will be populated if no unit (with or without\n   *    substitutions) could be found and suggestions were requested\n   */\n  _makeUnit(uCode, origString) {\n\n    // First try the code just as is, without looking for annotations,\n    // prefixes, exponents, or elephants.\n    let retUnit = this.utabs_.getUnitByCode(uCode);\n    if (retUnit) {\n      retUnit = retUnit.clone();\n    }\n\n    // If we found it, we're done.  No need to parse for those elephants (or\n    // other stuff).\n    else if (uCode.indexOf(this.braceFlag_) >= 0) {\n      let getAnnoRet = this._getUnitWithAnnotation(uCode, origString);\n      retUnit = getAnnoRet[0];\n      if (retUnit) {\n        origString = getAnnoRet[1];\n      }\n      // If a unit is not found, retUnit will be returned null and\n      // the this.retMsg_ array will contain a message describing the problem.\n      // If a unit is found, of course, all is good. So ... nothing left\n      // to see here, move along.\n    } // end if the uCode includes an annotation\n\n    else {\n\n      // So we didn't find a unit for the full uCode or for one with\n      // annotations.  Try looking for a unit that uses a carat (^)\n      // instead of an asterisk (*)\n\n      if (uCode.indexOf('^') > -1) {\n        let tryCode = uCode.replace('^', '*');\n        retUnit = this.utabs_.getUnitByCode(tryCode);\n        if (retUnit) {\n          retUnit = retUnit.clone();\n          retUnit.csCode_ = retUnit.csCode_.replace('*', '^');\n          retUnit.ciCode_ = retUnit.ciCode_.replace('*', '^');\n        }\n      }\n      // If that didn't work, check to see if it should have brackets\n      // around it (uCode = degF when it should be [degF]\n      if (!retUnit) {\n        let addBrackets = '[' + uCode + ']' ;\n        retUnit = this.utabs_.getUnitByCode(addBrackets);\n        if (retUnit) {\n          retUnit = retUnit.clone();\n          origString = origString.replace(uCode, addBrackets);\n          this.retMsg_.push(`${uCode} is not a valid unit expression, but ` +\n            `${addBrackets} is.\\n` + this.vcMsgStart_ +\n            `${addBrackets} (${retUnit.name_})${this.vcMsgEnd_}`);\n        } // end if we found the unit after adding brackets\n      } // end trying to add brackets\n\n      // If we didn't find it, try it as a name\n      if (!retUnit) {\n        let retUnitAry = this.utabs_.getUnitByName(uCode);\n        if (retUnitAry && retUnitAry.length > 0) {\n          retUnit = retUnitAry[0].clone();\n          let mString = 'The UCUM code for ' + uCode + ' is ' +\n            retUnit.csCode_ + '.\\n' + this.vcMsgStart_ +\n            retUnit.csCode_ + this.vcMsgEnd_;\n          let dupMsg = false;\n          for (let r = 0; r < this.retMsg_.length && !dupMsg; r++)\n            dupMsg = this.retMsg_[r] === mString;\n          if (!dupMsg)\n            this.retMsg_.push(mString);\n          let rStr = new RegExp('(^|[.\\/({])(' + uCode + ')($|[.\\/)}])');\n          let res = origString.match(rStr);\n          origString = origString.replace(rStr, res[1] + retUnit.csCode_ + res[3]);\n          uCode = retUnit.csCode_;\n        }\n      }\n\n      // If we still don't have a unit, try assuming a modifier (prefix and/or\n      // exponent) and look for a unit without the modifier\n      if (!retUnit) {\n\n        // Well, first see if it's one of the special units.  If so,\n        // replace the placeholder text with the actual unit string, keeping\n        // whatever text (probably a prefix) goes with the unit string.\n        let sUnit = null;\n        for (sUnit in Ucum.specUnits_) {\n          if (uCode.includes(Ucum.specUnits_[sUnit]))\n            uCode = uCode.replace(Ucum.specUnits_[sUnit], sUnit);\n        }\n        retUnit = this.utabs_.getUnitByCode(uCode);\n        if (retUnit)\n          retUnit = retUnit.clone();\n      }\n      if (!retUnit) {\n\n        let origCode = uCode;\n        let origUnit = null;\n        let exp = null;\n        let pfxCode = null;\n        let pfxObj = null;\n        let pfxVal = null;\n        let pfxExp = null;\n\n        // Look first for an exponent.  If we got one, separate it out and\n        // try to get the unit again\n        let codeAndExp = this._isCodeWithExponent(uCode);\n        if (codeAndExp) {\n          uCode = codeAndExp[0];\n          exp = codeAndExp[1];\n          origUnit = this.utabs_.getUnitByCode(uCode);\n        }\n        \n\n        // If we still don't have a unit, separate out the prefix, if any,\n        // and try without it.\n        if (!origUnit) {\n          // Try for a single character prefix first.\n          pfxCode = uCode.charAt(0);\n          pfxObj = this.pfxTabs_.getPrefixByCode(pfxCode);\n\n          // if we got a prefix, get its info and remove it from the unit code\n          if (pfxObj) {\n            pfxVal = pfxObj.getValue();\n            pfxExp = pfxObj.getExp();\n            let pCodeLen = pfxCode.length;\n            uCode = uCode.substr(pCodeLen);\n\n            // try again for the unit\n            origUnit = this.utabs_.getUnitByCode(uCode);\n\n            // If we still don't have a unit, see if the prefix could be the\n            // two character \"da\" (deka) prefix.  That's the only prefix with\n            // two characters, and without this check it's interpreted as \"d\"\n            // (deci) and the \"a\" is considered part of the unit code.\n\n            if (!origUnit && pfxCode == 'd' && uCode.substr(0, 1) == 'a') {\n              pfxCode = 'da';\n              pfxObj = this.pfxTabs_.getPrefixByCode(pfxCode);\n              pfxVal = pfxObj.getValue();\n              uCode = uCode.substr(1);\n\n              // try one more time for the unit\n              origUnit = this.utabs_.getUnitByCode(uCode);\n            }\n          } // end if we found a prefix\n        } // end if we didn't get a unit after removing an exponent\n\n        // If we still haven't found anything, we're done looking.\n        // (We tried with the full unit string, with the unit string\n        // without the exponent, the unit string without a prefix,\n        // common errors, etc. That's all we can try).\n        if (!origUnit) {\n          retUnit = null ;\n          // BUT if the user asked for suggestions, at least look for them\n          if (this.suggestions_) {\n            let suggestStat = this._getSuggestions(origCode);\n          }\n          else {\n            this.retMsg_.push(`${origCode} is not a valid UCUM code.`);\n          }\n        }\n        else {\n          // Otherwise we found a unit object.  Clone it and then apply the\n          // prefix and exponent, if any, to it.  And remove the guidance.\n          retUnit = origUnit.clone();\n          retUnit.guidance_ = '';\n          let theDim = retUnit.getProperty('dim_');\n          let theMag = retUnit.getProperty('magnitude_');\n          let theName = retUnit.getProperty('name_');\n          let theCiCode = retUnit.getProperty('ciCode_');\n          let thePrintSymbol = retUnit.getProperty('printSymbol_');\n          // If there is an exponent for the unit, apply it to the dimension\n          // and magnitude now\n          if (exp) {\n            exp = parseInt(exp);\n            let expMul = exp;\n            if (theDim)\n              theDim = theDim.mul(exp);\n            theMag = Math.pow(theMag, exp);\n            retUnit.assignVals({'magnitude_': theMag});\n\n            // If there is also a prefix, apply the exponent to the prefix.\n            if (pfxObj) {\n\n              // if the prefix base is 10 it will have an exponent.  Multiply\n              // the current prefix exponent by the exponent for the unit\n              // we're working with.  Then raise the prefix value to the level\n              // defined by the exponent.\n              if (pfxExp) {\n                expMul *= pfxObj.getExp();\n                pfxVal = Math.pow(10, expMul);\n              }\n              // If the prefix base is not 10, it won't have an exponent.\n              // At the moment I don't see any units using the prefixes\n              // that aren't base 10.   But if we get one the prefix value\n              // will be applied to the magnitude (below) if the unit does\n              // not have a conversion function, and to the conversion prefix\n              // if it does.\n            } // end if there's a prefix as well as the exponent\n          } // end if there's an exponent\n\n          // Now apply the prefix, if there is one, to the conversion\n          // prefix or the magnitude\n          if (pfxObj) {\n            if (retUnit.cnv_) {\n              retUnit.assignVals({'cnvPfx_': pfxVal});\n            }\n            else {\n              theMag *= pfxVal;\n              retUnit.assignVals({'magnitude_': theMag})\n            }\n          }\n          // if we have a prefix and/or an exponent, add them to the unit\n          // attributes - name, csCode, ciCode and print symbol\n          let theCode = retUnit.csCode_;\n          if (pfxObj) {\n            theName = pfxObj.getName() + theName;\n            theCode = pfxCode + theCode;\n            theCiCode = pfxObj.getCiCode() + theCiCode;\n            thePrintSymbol = pfxObj.getPrintSymbol() + thePrintSymbol;\n            retUnit.assignVals({\n              'name_': theName,\n              'csCode_': theCode,\n              'ciCode_': theCiCode,\n              'printSymbol_': thePrintSymbol\n            });\n          }\n          if (exp) {\n            let expStr = exp.toString();\n            retUnit.assignVals({\n              'name_': theName + '<sup>' + expStr + '</sup>',\n              'csCode_': theCode + expStr,\n              'ciCode_': theCiCode + expStr,\n              'printSymbol_': thePrintSymbol + '<sup>' + expStr + '</sup>'\n            });\n          }\n        } // end if an original unit was found (without prefix and/or exponent)\n\n      } // end if we didn't get a unit for the full unit code (w/out modifiers)\n    } // end if we didn't find the unit on the first try, before parsing\n    return [retUnit, origString];\n  } // end _makeUnit\n\n\n  /**\n   * This method handles unit creation when an annotation is included\n   * in the unit string.  This basically isolates and retrieves the\n   * annotation and then calls _makeUnit to try to get a unit from\n   * any text that precedes or follows the annotation.\n   *\n   * @param uCode the string defining the unit\n   * @param origString the original full string submitted to parseString\n   * @returns the unit object found, or null if one could not be found\n   *\n   * the this.retMsg_ array will be updated with any user messages\n   *   (informational, error or warning) generated by this or called methods\n   */\n  _getUnitWithAnnotation(uCode, origString) {\n\n    let retUnit = null;\n\n    // Get the annotation and anything that precedes or follows it.\n    let annoRet = this._getAnnoText(uCode, origString);\n    let annoText = annoRet[0];\n    let befAnnoText = annoRet[1];\n    let aftAnnoText = annoRet[2];\n\n    // Add the warning about annotations - just once.\n\n    if ((this.bracesMsg_) && (!this.retMsg_.includes(this.bracesMsg_)))\n      this.retMsg_.push(this.bracesMsg_);\n\n    // If there's no text before or after the annotation, it's probably\n    // something that should be interpreted as a 1, e.g., {KCT'U}.\n    // HOWEVER, it could also be a case where someone used braces instead\n    // of brackets, e.g., {degF} instead of [degF].  Check for that before\n    // we assume it should be a 1.\n    let msgLen = this.retMsg_.length;\n    if (!befAnnoText && !aftAnnoText) {\n      let tryBrackets = '[' + annoText.substring(1, annoText.length - 1) + ']';\n      let mkUnitRet = this._makeUnit(tryBrackets, origString);\n\n      // If we got back a unit, assign it to the returned unit, and add\n      // a message to advise the user that brackets should enclose the code\n      if (mkUnitRet[0]) {\n        retUnit = mkUnitRet[0];\n        origString = origString.replace(annoText, tryBrackets);\n        this.retMsg_.push(`${annoText} is not a valid unit expression, but ` +\n          `${tryBrackets} is.\\n` + this.vcMsgStart_ +\n          `${tryBrackets} (${retUnit.name_})${this.vcMsgEnd_}`);\n      }\n      // Otherwise assume that this should be interpreted as a 1\n      else {\n        // remove error message generated for trybrackets\n        if (this.retMsg_.length > msgLen) {\n          this.retMsg_.pop();\n        }\n        uCode = 1;\n        retUnit = 1;\n      }\n    } // end if it's only an annotation\n\n    else {\n      // if there's text before and no text after, assume the text before\n      // the annotation is the unit code (with an annotation following it).\n      // Call _makeUnit for the text before the annotation.\n      if (befAnnoText && !aftAnnoText) {\n        // make sure that what's before the annoText is not a number, e.g.,\n        // /100{cells}.  But f it is a number, just set the return unit to\n        // the number.\n        if (intUtils_.isNumericString(befAnnoText)) {\n          retUnit = befAnnoText ;\n        }\n        // Otherwise try to find a unit\n        else {\n          let mkUnitRet = this._makeUnit(befAnnoText, origString);\n\n          // if a unit was returned\n          if (mkUnitRet[0]) {\n            retUnit = mkUnitRet[0];\n            retUnit.csCode_ += annoText;\n            origString = mkUnitRet[1];\n          }\n          // Otherwise add a not found message\n          else {\n            this.retMsg_.push(`Unable to find a unit for ${befAnnoText} that ` +\n              `precedes the annotation ${annoText}.`);\n          }\n        }\n      }\n      // else if there's only text after the annotation, try for a unit\n      // from the after text and assume the user put the annotation in\n      // the wrong place (and tell them)\n      else if (!befAnnoText && aftAnnoText) {\n\n        // Again, test for a number and if it is a number, set the return\n        // unit to the number.\n        if (intUtils_.isNumericString(aftAnnoText)) {\n          retUnit = aftAnnoText + annoText ;\n          this.retMsg_.push(`The annotation ${annoText} before the `\n            `${aftAnnoText} is invalid.\\n` + this.vcMsgStart_ + retUnit +\n            this.vcMsgEnd_);\n        }\n        else {\n          let mkUnitRet = this._makeUnit(aftAnnoText, origString);\n          if (mkUnitRet[0]) {\n            retUnit = mkUnitRet[0];\n            retUnit.csCode_ += annoText;\n            origString = retUnit.csCode_;\n            this.retMsg_.push(`The annotation ${annoText} before the unit ` +\n              `code is invalid.\\n` + this.vcMsgStart_ + retUnit.csCode_ +\n              this.vcMsgEnd_);\n          }\n          // Otherwise add a not found message\n          else {\n            this.retMsg_.push(`Unable to find a unit for ${befAnnoText} that ` +\n              `follows the annotation ${annoText}.`);\n          }\n        }\n      }\n      // else it's got text before AND after the annotation.  Now what?\n      // For now this is an error.  This may be a case of a missing\n      // operator but that is not handled yet.\n      else {\n        this.retMsg_.push(`Unable to find a unit for ${befAnnoText}${annoText}` +\n          `${aftAnnoText}.\\nWe are not sure how to interpret text both before ` +\n          `and after the annotation.  Sorry`);\n      }\n    } // else if there's text before/and or after the annotation\n\n    return [retUnit , origString];\n\n  } // end _getUnitWithAnnotations\n\n\n  /**\n   * Performs unit arithmetic for the units in the units array.  That array\n   * contains units/numbers and the operators (division or multiplication) to\n   * be performed on each unit/unit or unit/number pair in the array.  This\n   * should only be called from within this class (or by test code).\n   *\n   * @params uArray the array that contains the units, numbers and operators\n   *  derived from the unit string passed in to parseString\n   * @param origString the original string to be parsed; used to provide\n   *  context for messages\n   * @returns a single unit object that is the result of the unit arithmetic\n   *\n   * the this.retMsg_ array will be updated with any user messages\n   *   (informational, error or warning) generated by this or called methods\n   */\n  _performUnitArithmetic(uArray, origString) {\n\n    let finalUnit = uArray[0]['un'];\n    if (intUtils_.isNumericString(finalUnit)) {\n      finalUnit = new Unit({'csCode_' : finalUnit,\n        'magnitude_' : Number(finalUnit),\n        'name_' : finalUnit}) ;\n    }\n    let uLen = uArray.length ;\n    let endProcessing = false ;\n    // Perform the arithmetic for the units, starting with the first 2 units.\n    // We only need to do the arithmetic if we have more than one unit.\n    for (let u2 = 1; (u2 < uLen) && !endProcessing; u2++) {\n      let nextUnit = uArray[u2]['un'];\n      if (intUtils_.isNumericString(nextUnit)) {\n        nextUnit = new Unit({'csCode_' : nextUnit ,\n          'magnitude_' : Number(nextUnit),\n          'name_': nextUnit});\n      }\n      if (nextUnit === null ||\n          ((typeof nextUnit !== 'number') && (!nextUnit.getProperty))) {\n        let msgString = `Unit string (${origString}) contains unrecognized ` +\n                        'element' ;\n        if (nextUnit) {\n          msgString += ` (${this.openEmph_}${nextUnit.toString()}` +\n                       `${this.closeEmph_})`;\n        }\n        msgString += '; could not parse full string.  Sorry';\n        this.retMsg_.push(msgString);\n        endProcessing = true;\n      }\n      else {\n        try {\n          // Is the operation division?\n          let thisOp = uArray[u2]['op'];\n          let isDiv = thisOp === '/';\n\n          // Perform the operation.  Both the finalUnit and nextUnit\n          // are unit objects.\n          isDiv ? finalUnit = finalUnit.divide(nextUnit) :\n                  finalUnit = finalUnit.multiplyThese(nextUnit);\n        }\n        catch (err) {\n          this.retMsg_.unshift(err.message) ;\n          endProcessing = true ;\n          finalUnit = null ;\n        }\n      } // end if we have another valid unit/number to process\n    } // end do for each unit after the first one\n    return finalUnit ;\n  }  // end _performUnitArithmetic\n\n\n  /**\n   * This tests a string to see if it starts with characters and ends with\n   * digits.  This is used to test for an exponent on a UCUM code (or what\n   * we think might be a UCUM code).  This is broken out to a separate\n   * function so that the regular expression can be verified to provide the\n   * results we expect, in case someone changes it.  (Per Paul Lynch)\n   * See \"Test _isCodeWithExponent method\" in testUnitString.spec.js\n   *\n   * This particular regex has been tweaked several times.  This one\n   * works with the following test strings:\n   * \"m[H2O]-21 gives [\"m[H2O]-21\", \"m[H2O]\", \"-21\"]\n   * \"m[H2O]+21 gives [\"m[H2O]+21\", \"m[H2O]\", \"+21\"]\n   * \"m[H2O]21 gives [\"m[H2O]-21\", \"m[H2O]\", \"21\"]\n   * \"s2\" gives [\"s2\", \"s, \"2\"]\n   * \"kg\" gives null\n   * \"m[H2O]\" gives null\n   * \"m[H2O]23X\" gives null\n   *\n   * @params uCode the code being tested\n   * @returns an array containing: (1) the code without the exponent (or\n   *  trailing number); and (2) the exponent/trailing number.  Returns null\n   *  if there is no trailing number or something follows the trailing\n   *  number, or if the first part is not characters.\n   */\n  _isCodeWithExponent(uCode) {\n\n    let ret = [] ;\n    let res = uCode.match(/(^[^\\-\\+]+?)([\\-\\+\\d]+)$/);\n\n    // If we got a return with an exponent, separate the exponent from the\n    // unit and return both (as separate values)\n    if (res && res[2] && res[2] !== \"\") {\n      ret.push(res[1]);\n      ret.push(res[2]);\n    } // end if we got an exponent\n    else {\n      ret = null ;\n    }\n    return ret ;\n  } // end _isCodeWithExponent\n\n} // end class UnitString\n\n\n/**\n *  This function exists ONLY until the original UnitString constructor\n *  is called for the first time.  It's defined here in case getInstance\n *  is called before the constructor.   This calls the constructor.\n *\n *  The constructor redefines the getInstance function to return the\n *  singleton UnitString object.  This is based on the UnitTables singleton\n *  implementation; see more detail in the UnitTables constructor description.\n *\n *  @return the singleton UnitString object.\n */\nUnitString.getInstance = function(){\n  return new UnitString();\n} ;\n\n/*\n// Perform the first request for the object, to set the getInstance method.\nUnitString.getInstance();\n\n*/"]}